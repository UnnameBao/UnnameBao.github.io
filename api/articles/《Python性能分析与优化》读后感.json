{"title":"《Python性能分析与优化》读后感","slug":"《Python性能分析与优化》读后感","date":"2018-01-14T06:55:09.000Z","updated":"2019-09-12T06:22:21.000Z","comments":true,"path":"api/articles/《Python性能分析与优化》读后感.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p> <a href=\"http://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\" target=\"_blank\" rel=\"noopener\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/79056049\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/s1054436218/article/details/79056049</a>   </p>\n<p>   最近读了《Python性能分析与优化》，前面大部分章节都是介绍性能分析工具以及一些比较简单的优化方式（重复运算查表之类的常识），可能是我第一次阅读，挖掘的干活不算很多，不过还想来总结分享一下。</p>\n<p> 首先介绍一些关于Python特性的优化利用。</p>\n<p> 一、循环、列表综合表达式、生成器表达式</p>\n<p> 书中有列举循环和列表的运行时间对比，由于我主要用的是Python3，所以我改成了Python3的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">\t@DateTime: \t2017-12-18 09:56:15</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">import dis</span><br><span class=\"line\">import inspect</span><br><span class=\"line\">import timeit</span><br><span class=\"line\"></span><br><span class=\"line\">programs = dict(</span><br><span class=\"line\">loop = &apos;&apos;&apos;</span><br><span class=\"line\">multiples_of_two = []</span><br><span class=\"line\">for x in range(100):</span><br><span class=\"line\">\tif x%2 == 0:</span><br><span class=\"line\">\t\tmultiples_of_two.append(x)</span><br><span class=\"line\">&apos;&apos;&apos;,\t#loop是循环的代码</span><br><span class=\"line\">\tcomprehension = &apos;multiples_of_two = [x for x in range(100) if x % 2 == 0]&apos;,\t#comprehension是列表综合生成式代码</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">for name , text in programs.items():</span><br><span class=\"line\">\tprint(name,timeit.Timer(stmt = text).timeit())\t#打印运行时间</span><br><span class=\"line\">\tcode = compile(text,&apos;&lt;string&gt;&apos;,&apos;exec&apos;)\t#编译</span><br><span class=\"line\">\tdis.disassemble(code)\t#输出生成的机器码</span><br></pre></td></tr></table></figure>\n\n\n<p> 上面的代码是对比生成100以内偶数的代码，以下是运行结果（当然，是Python3的）： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop 10.350648703367305</span><br><span class=\"line\">  2           0 BUILD_LIST               0</span><br><span class=\"line\">              2 STORE_NAME               0 (multiples_of_two)</span><br><span class=\"line\"></span><br><span class=\"line\">  3           4 SETUP_LOOP              38 (to 44)</span><br><span class=\"line\">              6 LOAD_NAME                1 (range)</span><br><span class=\"line\">              8 LOAD_CONST               0 (100)</span><br><span class=\"line\">             10 CALL_FUNCTION            1</span><br><span class=\"line\">             12 GET_ITER</span><br><span class=\"line\">        &gt;&gt;   14 FOR_ITER                26 (to 42)</span><br><span class=\"line\">             16 STORE_NAME               2 (x)</span><br><span class=\"line\"></span><br><span class=\"line\">  4          18 LOAD_NAME                2 (x)</span><br><span class=\"line\">             20 LOAD_CONST               1 (2)</span><br><span class=\"line\">             22 BINARY_MODULO</span><br><span class=\"line\">             24 LOAD_CONST               2 (0)</span><br><span class=\"line\">             26 COMPARE_OP               2 (==)</span><br><span class=\"line\">             28 POP_JUMP_IF_FALSE       14</span><br><span class=\"line\"></span><br><span class=\"line\">  5          30 LOAD_NAME                0 (multiples_of_two)</span><br><span class=\"line\">             32 LOAD_ATTR                3 (append)</span><br><span class=\"line\">             34 LOAD_NAME                2 (x)</span><br><span class=\"line\">             36 CALL_FUNCTION            1</span><br><span class=\"line\">             38 POP_TOP</span><br><span class=\"line\">             40 JUMP_ABSOLUTE           14</span><br><span class=\"line\">        &gt;&gt;   42 POP_BLOCK</span><br><span class=\"line\">        &gt;&gt;   44 LOAD_CONST               3 (None)</span><br><span class=\"line\">             46 RETURN_VALUE</span><br><span class=\"line\">comprehension 8.135235990133049</span><br><span class=\"line\">  1           0 LOAD_CONST               0 (&lt;code object &lt;listcomp&gt; at 0x00000258440AA5D0, file &quot;&lt;string&gt;&quot;, line 1&gt;)</span><br><span class=\"line\">              2 LOAD_CONST               1 (&apos;&lt;listcomp&gt;&apos;)</span><br><span class=\"line\">              4 MAKE_FUNCTION            0</span><br><span class=\"line\">              6 LOAD_NAME                0 (range)</span><br><span class=\"line\">              8 LOAD_CONST               2 (100)</span><br><span class=\"line\">             10 CALL_FUNCTION            1</span><br><span class=\"line\">             12 GET_ITER</span><br><span class=\"line\">             14 CALL_FUNCTION            1</span><br><span class=\"line\">             16 STORE_NAME               1 (multiples_of_two)</span><br><span class=\"line\">             18 LOAD_CONST               3 (None)</span><br><span class=\"line\">             20 RETURN_VALUE</span><br><span class=\"line\"></span><br><span class=\"line\">***Repl Closed***</span><br></pre></td></tr></table></figure>\n\n\n<p> 可以看到。循环和综合表达式生成的机器码行数就不一样，如果你使用的是python2运行，生成的行数会更多。所以，在生成列表时应该尽量使用综合列表表达式，不仅使用简单而且生成更少的机器码，并且运行时间更少。 </p>\n<p> 关于生成器表达式，使用方法和列表表达式是类似的，就是把中括号换成小括号就可以了，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_list = (i**2 for i in range(100))</span><br></pre></td></tr></table></figure>\n\n<p>但生成器有个缺点是不能随机接入，即只可以遍历使用： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; my_list[1]\t#这样使用会报错</span><br><span class=\"line\">Traceback (most recent call last):</span><br><span class=\"line\">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class=\"line\">TypeError: &apos;generator&apos; object has no attribute &apos;__getitem__&apos;</span><br><span class=\"line\">&gt;&gt;&gt; for i in my_list:</span><br><span class=\"line\">...     print(i)</span><br><span class=\"line\">...</span><br><span class=\"line\">0</span><br><span class=\"line\">1</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>生成器和列表表达式在不同的数据量中表现不同，数据量越小使用列表表达式创建列表越快，数据量越大使用生成器创建列表越快。 </p>\n<p> 二、Ctypes</p>\n<p> 这个特性只存在于CPython中，ctypes可以使开发者借助C直接进行底层开发，实现C语言的功能，也可以通过这个库调用共享链接库（so、dll），并且可以借此绕过GIL（总所周知Python是伪多线程，而GIL是Python在设计中限制Python多线程的机制，就是说因为GIL的存在Python无法实现真正的多线程，但是在调用机器码时可以绕过该机制。）</p>\n<p> 下面是一个简单的生成随机数对比代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">\t@DateTime: \t2018-01-14 14:06:34</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">import time</span><br><span class=\"line\">import random</span><br><span class=\"line\">from ctypes import cdll</span><br><span class=\"line\">libc = cdll.msvcrt</span><br><span class=\"line\">#libc = cdll.LoadLibrary(&apos;libc.so.6&apos;)\t#Linux系统</span><br><span class=\"line\"></span><br><span class=\"line\">init = time.time()</span><br><span class=\"line\">randoms = [random.randint(1,100) for i in range(1000000)]</span><br><span class=\"line\">print(&apos;Pure python: %s seconds&apos;%(time.time() - init))</span><br><span class=\"line\"></span><br><span class=\"line\">init = time.time()</span><br><span class=\"line\">randoms = [(libc.rand()%100+1) for i in range(1000000)]</span><br><span class=\"line\">print(&apos;C version: %s seconds&apos;%(time.time() - init))</span><br></pre></td></tr></table></figure>\n\n<p>输出结果： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Pure python: 1.5020687580108643 seconds</span><br><span class=\"line\">C version: 0.5097446441650391 seconds</span><br><span class=\"line\"></span><br><span class=\"line\">***Repl Closed***</span><br></pre></td></tr></table></figure>\n\n\n<p> ctype当然可以调用自己写的dll，这个我就不举例了。 </p>\n<p> 三、字符串连接</p>\n<p> 这个涉及到我之前写的一篇文章，当时其实写错了，但我不修改了，大家看到知道就行了：<a href=\"http://blog.csdn.net/s1054436218/article/details/78637048\" target=\"_blank\" rel=\"noopener\">关于python3中整数数组转bytes的效率问题</a></p>\n<p> 这个大家可以就当成例子看，不过原理写错了，实际上真正的原因是Python的字符串特性。</p>\n<p> 字符串在Python在内存中是静态值，也就是说Python的字符串变量只不过是指向了内存中的静态值，这一点跟Java类似，看下面的输出结果大家就懂了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; str1 = &apos;Unname_Bao&apos;</span><br><span class=\"line\">&gt;&gt;&gt; str2 = &apos;Unname_Bao&apos;</span><br><span class=\"line\">&gt;&gt;&gt; id(str1)</span><br><span class=\"line\">2020390278064</span><br><span class=\"line\">&gt;&gt;&gt; id(str2)</span><br><span class=\"line\">2020390278064</span><br><span class=\"line\">&gt;&gt;&gt; str1 = str1+str2</span><br><span class=\"line\">&gt;&gt;&gt; id(str2)</span><br><span class=\"line\">2020390278064</span><br><span class=\"line\">&gt;&gt;&gt; id(str1)</span><br><span class=\"line\">2020390263736</span><br></pre></td></tr></table></figure>\n\n<p>str1和str2的值相同，他们内存中指向的静态值就相同，而一旦对str1进行修改，就会申请新的内存地址，然后让str1和str2连接的运算结果存在新申请的内存地址中，然后让str1指向新申请的内存地址。也就是说任何字符串修改都会让python重新申请内存地址，所以在我之前的文章中才会遇到跑十几分钟跑不出来的问题，但是改成列表运算就可以几秒钟内跑出来了。  </p>\n<p> 四、多线程与多进程</p>\n<p> 之前也提到了，由于GIL的存在，python的多线程实际上是伪多线程，但是可以通过调用dll绕过GIL，纯python代码的多线程仅适用于IO密集型操作中，否则反而会使效率降低，这些都是老生常谈的话题了。</p>\n<p> python的多进程是真的多进程，不过我对多进程的使用的还比较少，这篇文章主要是想帮大家了解一下提高代码效率的方法，所以想要了解并使用多进程的话，可以百度一下。</p>\n<p> 五、JIT</p>\n<p> 不知道JIT（just in time）的可以了解一下，Python是一个解释型语言，就是边运行边翻译，JIT技术是指在第一次运行的时候进行编译，例如第一次运行sum的时候，先进行编译再运行，下次再调用sum的时候，由于是直接调用的机器码，就可以减少很多时间。Java就是通过JIT技术成为解释型语言中的性能怪兽的。</p>\n<p> 当然这也带来一个问题就是第一次调用函数的时候反而会降低效率，接下来给大家举个例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">\t@DateTime: \t2018-01-14 12:50:35</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&apos;&apos;&apos;</span><br><span class=\"line\">from numba import jit</span><br><span class=\"line\">import random</span><br><span class=\"line\">import time</span><br><span class=\"line\"># import numpy</span><br><span class=\"line\"></span><br><span class=\"line\">@jit</span><br><span class=\"line\">def sum1(a):\t#sum1使用jit技术</span><br><span class=\"line\">\ts = 0</span><br><span class=\"line\">\tfor i in a:</span><br><span class=\"line\">\t\ts = s +i</span><br><span class=\"line\">\treturn s</span><br><span class=\"line\"></span><br><span class=\"line\">def sum2(a):\t#sum2没有使用jit技术</span><br><span class=\"line\">\ts = 0</span><br><span class=\"line\">\tfor i in a:</span><br><span class=\"line\">\t\ts = s + i</span><br><span class=\"line\">\treturn s</span><br><span class=\"line\"></span><br><span class=\"line\">a = [random.randint(0,1000) for i in range(1000000)]</span><br><span class=\"line\"></span><br><span class=\"line\">init = time.time()</span><br><span class=\"line\">print(sum1(a))</span><br><span class=\"line\">print(time.time()-init)</span><br><span class=\"line\"></span><br><span class=\"line\">init = time.time()</span><br><span class=\"line\">print(sum2(a))</span><br><span class=\"line\">print(time.time()-init)</span><br><span class=\"line\"></span><br><span class=\"line\">init = time.time()</span><br><span class=\"line\">print(sum1(a))</span><br><span class=\"line\">print(time.time()-init)</span><br></pre></td></tr></table></figure>\n\n<p>numba是提高Python的一个第三方库之一，是解决Python效率的方案之一，提供JIT、GIT绕过和调用GPU，但它JIT的使用适用范围有限，可能会不支持第三方库的数据类型。大家了解一下便好，接下来是运行结果： </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">500335531</span><br><span class=\"line\">0.18614816665649414</span><br><span class=\"line\">500335531</span><br><span class=\"line\">0.04512643814086914</span><br><span class=\"line\">500335531</span><br><span class=\"line\">0.0170440673828125</span><br><span class=\"line\"></span><br><span class=\"line\">***Repl Closed***</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<p> 可见第一次调用sum1比第二次调用sum1慢的多，但一旦编译好，sum1的速度就比sum2要快了。</p>\n<p> 以上算是我阅读完这本书后的小结了，第一次阅读感觉干货不算很多，勉强可以总结成一篇文章，大部分优化方法都了解过或者算是常识了，不过也让我了解到了一些我对Python的误解，也算是有收获吧。</p>\n","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":25,"path":"api/tags/CSDN迁移.json"}]}