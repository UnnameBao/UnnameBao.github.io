{"title":"关于python3中整数数组转bytes的效率问题","slug":"关于python3中整数数组转bytes的效率问题","date":"2017-11-26T06:10:06.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/关于python3中整数数组转bytes的效率问题.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78637048\">https://blog.csdn.net/s1054436218/article/details/78637048</a></p>\n<p>昨天在做一道CTF题的时候碰到了一个图片异或的问题，操作大概如下：</p>\n<p>将一个图片读入，然后每字节进行异或操作，核心代码可简化为以下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-25 13:51:33</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">import six</span><br><span class=\"line\">key &#x3D; b&#39;\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d&#39;</span><br><span class=\"line\">with open(&#39;flag.encrypted&#39;,&#39;rb&#39;) as f:</span><br><span class=\"line\">\tc &#x3D; f.read()</span><br><span class=\"line\">flag &#x3D; b&#39;&#39;</span><br><span class=\"line\">for i in range(32):</span><br><span class=\"line\">\tflag +&#x3D; six.int2byte(key[i%32]^c[i])</span><br><span class=\"line\">with open(&#39;flag.png&#39;,&#39;wb&#39;) as f:</span><br><span class=\"line\">\tf.write(flag)</span><br></pre></td></tr></table></figure>\n<p>然后就碰到了一个效率问题，跑了十几分钟都没有跑出结果，起初以为是类型转换的问题，因为比较急，于是换了成了C++的代码去解决，后来一直没多想。今天闲下来的时候才发现代码之前的代码中存在一个非常大的问题：内存申请问题。</p>\n<p>由于flag.encrypted文件大小为6.47MB之大，由于我的脚本思路是不断在byte数组后添加，但忽略了其本质。就是在内存申请过程中，由于数组长度最终为600+W大小，期间存在多次数组内存不够，需要重新申请内存的问题，而python中的内存申请显然没有C++的vector的push_back有效率。而且python中，无论是list、string还是byte，也没有reserve这种函数，不能预留内存空间（这时候真的要吐槽一下python设计者对速度优化的考量了）。于是只能用另一种方法进行优化，就是先用list申请一个需求大小的内存空间，然后再转为bytes使用，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-26 14:09:29</span><br><span class=\"line\">\t@Version: \t2.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">key &#x3D; b&#39;\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d&#39;</span><br><span class=\"line\">with open(&#39;flag.encrypted&#39;,&#39;rb&#39;) as f:</span><br><span class=\"line\">\tc &#x3D; f.read()</span><br><span class=\"line\">flag &#x3D; list(&#39;1&#39;*len(c))</span><br><span class=\"line\">for i in  range(len(c)):</span><br><span class=\"line\">\tflag[i] &#x3D; key[i%32]^c[i]</span><br><span class=\"line\">flag &#x3D; bytes(flag)</span><br><span class=\"line\">with open(&#39;flag.png&#39;,&#39;wb&#39;) as f:</span><br><span class=\"line\">\tf.write(flag)</span><br></pre></td></tr></table></figure>\n<p>这样写的话几乎是瞬间完成任务了，但还是比C++慢很多，这是不可避免的。</p>\n","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]}