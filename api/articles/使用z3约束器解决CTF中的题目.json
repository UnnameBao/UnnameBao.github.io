{"title":"使用z3约束器解决CTF中的题目","slug":"使用z3约束器解决CTF中的题目","date":"2017-11-28T02:53:22.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/使用z3约束器解决CTF中的题目.json","photos":[],"link":"","excerpt":null,"covers":null,"content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78651075\">https://blog.csdn.net/s1054436218/article/details/78651075</a></p>\n<p>Z3是什么？Z3由微软开发的一套约束求解器，你可以简单的理解它是解方程的神器。在CTF题目中，我们经常遇到一些给定的条件，或是算法难以逆向、或是涉及到未知的数学技巧又或是爆破时间过长，而在我们学会使用z3后，一类问题便迎刃而解了。想了解更多关于z3知识的，这里有篇专栏：<a href=\"https://zhuanlan.zhihu.com/p/30548907\">点我</a></p>\n<p>一个简单的例子给大家介绍一下z3如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from z3 import *</span><br><span class=\"line\">&gt;&gt;&gt; x &#x3D; Int(&#39;x&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; y &#x3D; Int(&#39;y&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; solve(x+y&#x3D;&#x3D;4)</span><br><span class=\"line\">[y &#x3D; 0, x &#x3D; 4]</span><br></pre></td></tr></table></figure>\n<p>它为我们提供了一个关于x+y==4的解，可是如果我们想要x=3呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; solve(x&#x3D;&#x3D;3,x+y&#x3D;&#x3D;4)</span><br><span class=\"line\">[y &#x3D; 1, x &#x3D; 3]</span><br></pre></td></tr></table></figure>\n<p>当然了，z3能做的肯定不止这么简单的运算，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from z3 import *</span><br><span class=\"line\">&gt;&gt;&gt; x &#x3D; Real(&#39;x&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; y &#x3D; Real(&#39;y&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; solve(x**2 + y**2 &#x3D;&#x3D; 3, x**3 &#x3D;&#x3D; 2)</span><br><span class=\"line\">[x &#x3D; 1.2599210498?, y &#x3D; -1.1885280594?]</span><br></pre></td></tr></table></figure>\n<p>OK，大概了解到它是干嘛的我们就开始看一道例题吧。二进制文件可以在<a href=\"https://github.com/UnnameBao/My_ctf_path/tree/master/blog/I_Hate_Math\">这里</a>下载。</p>\n<p>这是whctf的一道逆向题，它的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 &#x3D; 0;</span><br><span class=\"line\">gets(flag);</span><br><span class=\"line\">for ( i &#x3D; 0; i &lt;&#x3D; 35; ++i )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if ( !flag[i] )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    flag[i] &#x3D; 1;</span><br><span class=\"line\">    ++v1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if ( v1 !&#x3D; 9 )</span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">convert(a);</span><br><span class=\"line\">Transposition(a);</span><br><span class=\"line\">Multi(a, b);</span><br><span class=\"line\">for ( j &#x3D; 0; j &lt;&#x3D; 5; ++j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  for ( k &#x3D; 0; k &lt;&#x3D; 5; ++k )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if ( c[0][k + 6 * j] !&#x3D; d[0][k + 6 * j] )</span><br><span class=\"line\">      exit(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printf(&quot;congratulations!you have gottern the flag!&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中convert(a)是将flag赋值给a，你可以把a当做一个6*6的矩阵。 Transposition(a)是把a的转置矩阵赋值给b</p>\n<p>Multi(a,b)是把a和b的乘积赋值给c</p>\n<p>而d就是堆中正确的flag经过上述运算后的结果，也就是说，如果用简单的思路去做，就是想办法爆破27位的flag添加9位1到尾部，然后经过运算结果为d中的值。但未知位数已经达到了20个，常规的爆破思路很难解决，网上的一篇writeup是经过一系列数学运算后逐行爆破，但每行依旧要消耗近10分钟的时间。在实际比赛的过程中，时间始终是最宝贵的，况且如果你对线性代数不太理解，可能会有一些棘手。</p>\n<p>首先数学知识当然是必要的，我们应该保持着一个敬畏之心去学习这里的数学原理，但为了节省时间，或许用约束器去做会有意想不到的效果。</p>\n<p>以下是我的脚本，注释的很详细就不多说了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-28 10:19:29</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">from z3 import *</span><br><span class=\"line\">import time</span><br><span class=\"line\">t1 &#x3D; time.time()</span><br><span class=\"line\">#创建一个解决方案实例</span><br><span class=\"line\">solver &#x3D; Solver()</span><br><span class=\"line\">#flag长度先设置为36，包括尾部的9个1</span><br><span class=\"line\">flag &#x3D; [Int(&#39;flag%d&#39;%i) for i in range(36)]</span><br><span class=\"line\">#保存flag的矩阵</span><br><span class=\"line\">a &#x3D; [i for i in flag]</span><br><span class=\"line\">#保存flag的转置矩阵</span><br><span class=\"line\">b &#x3D; [i for i in range(36)]</span><br><span class=\"line\">#保存a*b的矩阵</span><br><span class=\"line\">c &#x3D; [0 for i in range(36)]</span><br><span class=\"line\">#堆中正确flag的运算结果</span><br><span class=\"line\">d &#x3D; [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297,</span><br><span class=\"line\">\t0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230,</span><br><span class=\"line\">\t0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD,</span><br><span class=\"line\">\t0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7,</span><br><span class=\"line\">\t0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C,</span><br><span class=\"line\">\t0x297,0x230,0x1BD,0x1F7,0x15C,0x6]</span><br><span class=\"line\">#获得a的转置矩阵</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tfor j in range(6):</span><br><span class=\"line\">\t\tb[i+6*j] &#x3D; a[6*i+j]</span><br><span class=\"line\">#运算a*b</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tfor j in range(6):</span><br><span class=\"line\">\t\tfor k in range(6):</span><br><span class=\"line\">\t\t\tc[j+6*i] &#x3D; c[j+6*i] + a[6*i+k]*b[6*k+j]</span><br><span class=\"line\">\t\t#添加约束，正确flag的运算结果</span><br><span class=\"line\">\t\tsolver.add(simplify(c[j+6*i]) &#x3D;&#x3D; d[j+6*i])</span><br><span class=\"line\">#添加约束，除了尾部，flag的字符一定在可见字符范围内</span><br><span class=\"line\">for i in range(6,36-10):</span><br><span class=\"line\">\tsolver.add(flag[i]&gt;&#x3D;32)</span><br><span class=\"line\">\tsolver.add(flag[i]&lt;&#x3D;127)</span><br><span class=\"line\">#添加约束，由于flag有格式，前6位一定为whctf&#123;</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tsolver.add(flag[i] &#x3D;&#x3D; ord(&#39;whctf&#123;&#39;[i]))</span><br><span class=\"line\">#添加约束，flag的尾部为9个1</span><br><span class=\"line\">for i in range(36-9,36):</span><br><span class=\"line\">\tsolver.add(flag[i] &#x3D;&#x3D; 0x1)</span><br><span class=\"line\">#添加约束，flag的最后一个肯定是&#125;</span><br><span class=\"line\">solver.add(flag[-10] &#x3D;&#x3D; ord(&#39;&#125;&#39;))</span><br><span class=\"line\">#这里一定要有，不check的话会报错</span><br><span class=\"line\">if solver.check() &#x3D;&#x3D; sat:</span><br><span class=\"line\">\tm &#x3D; solver.model()</span><br><span class=\"line\">\ts &#x3D; []</span><br><span class=\"line\">\t#获得结果</span><br><span class=\"line\">\tfor i in range(36):</span><br><span class=\"line\">\t\ts.append(m[flag[i]].as_long())</span><br><span class=\"line\">\t#输出flag</span><br><span class=\"line\">\tprint(bytes(s))</span><br><span class=\"line\">else:</span><br><span class=\"line\">\tprint(&#39;error&#39;)</span><br><span class=\"line\">t2 &#x3D; time.time()</span><br><span class=\"line\">print(t2-t1)</span><br></pre></td></tr></table></figure>\n<p>这是最终的运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\2017_WEB_Test\\ulb_manager\\backend\\spider&gt;python z3test.py</span><br><span class=\"line\">b&#39;whctf&#123;Y0u_ar3_g00d_a7_m4th&#125;\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01&#39;</span><br><span class=\"line\">4.042840003967285</span><br></pre></td></tr></table></figure>\n<p>是的，仅仅用了4s就跑出了最终结果、可见z3约束器的强大！</p>\n<p>更多信息请看z3的官方GitHub：<a href=\"https://github.com/Z3Prover/z3\">点我</a></p>\n","categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]}