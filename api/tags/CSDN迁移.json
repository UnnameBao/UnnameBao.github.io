{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"postlist":[{"title":"Python3.6安装pycrypto2.61","slug":"Python3.6安装pycrypto2.61","date":"2017-09-20T11:32:01.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/Python3.6安装pycrypto2.61.json","excerpt":"","keywords":null,"cover":"../../../../image/31.png","content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78044524\">https://blog.csdn.net/s1054436218/article/details/78044524</a></p>\n<p>本来以为自己的Python3.6早就装好了pycrypto，结果发现只是装在了自己的python2.7，因为想要用python3开发后台，利用pycrypto会省很多事儿，于是pip install pycrypto。</p>\n<p>后来会报错误：</p>\n<p>error: command ‘C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\x86_amd64\\cl.exe’ failed with exit status 1158 command ‘C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\x86_amd64\\cl.exe’ failed with exit status 2</p>\n<p>然后百度了半天都是瞎扯的，在google上搜到了一个解决方法（假设本机安装了Microsoft Visual Studio2017 Community版）：</p>\n<p>第一步：将D:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Community\\VC\\Tools\\MSVC\\14.10.25017\\include\\stdint.h文件拷贝到C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.15063.0\\ucrt\\目录下</p>\n<p>第二步：修改C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.15063.0\\ucrt\\inttypes.h中的第13行，将</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &lt;stdint.h&gt;</span><br></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include &quot;stdint.h&quot;</span><br></pre></td></tr></table></figure>\n<p>然后再次安装，出现了新问题：</p>\n<p>error: command ‘C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\BIN\\x86_amd64\\link.exe’ failed with exit status 1158</p>\n<p>然后继续google之，一个外国朋友给了一个解决方法：</p>\n<p>第一步：将C:\\Program Files (x86)\\Windows Kits\\10\\bin\\x64 加入path</p>\n<p>第二部：将rc.exe和rcdll.dll两个文件从</p>\n<p>C:\\Program Files (x86)\\Windows Kits\\8.1\\bin\\x86</p>\n<p>复制到</p>\n<p>C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin</p>\n<p>到此，我已经安装成功了，可是import的时候又出现问题：</p>\n<p>ModuleNotFoundError: No module named ‘Crypto’</p>\n<p>原来是因为安装过crypto，再安装pycrypto的时候就会 有冲突，于是卸载掉两个，重新安装pycrypto，新的问题又出现了：</p>\n<p>ModuleNotFoundError: No module named winrandom</p>\n<p>这次百度解决了：</p>\n<p>修改python3安装目录下的 lib/Crypto/Random/OSRNG/nt.py 文件中找到</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import winrandom</span><br></pre></td></tr></table></figure>\n<p>修改为：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from Crypto.Random.OSRNG import winrandom</span><br></pre></td></tr></table></figure>\n<p>OK，到此就解决全部问题了！~ <img src=\"../../../../image/31.png\" alt=\"\" /></p>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/78044524本来以为自己的Python3.6早就装好了","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"Python利用Socket实现文件上传和下载","slug":"Python利用Socket实现文件上传和下载","date":"2017-09-24T06:49:00.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/Python利用Socket实现文件上传和下载.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78076845\">https://blog.csdn.net/s1054436218/article/details/78076845</a></p>\n<p>第一次写Socket，大家见笑了。注释都很清楚，不多说了。</p>\n<p>值得一提的是中间碰到过一个bug是：</p>\n<p>unpack requires a bytes object of length</p>\n<p>百度了半天，某些博主扯了好多都没说清楚</p>\n<p>其实就是用struct打包了以后字符串流的大小会固定，但是你接收的大小跟你指定的编码方式不一样</p>\n<p>我这次出错是因为在发压缩包之前先发了个串，然后服务器接到的不是压缩的串所以出错了，所以unpack接收的必须是你pack后的串，不然会出错</p>\n<p>OK，以下是服务器端的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-09-24 12:25:13</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Max</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">import threading</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import time</span><br><span class=\"line\">import operator</span><br><span class=\"line\">import os</span><br><span class=\"line\">import struct</span><br><span class=\"line\"></span><br><span class=\"line\">#实现下载功能</span><br><span class=\"line\">def download(connect):</span><br><span class=\"line\">\t#获取文件目录</span><br><span class=\"line\">\tfiles &#x3D; os.listdir()</span><br><span class=\"line\">\t#用于传输文件目录的字符串</span><br><span class=\"line\">\tliststr &#x3D; &#39;&#39;</span><br><span class=\"line\">\t#将所有文件名传入字符串中</span><br><span class=\"line\">\tfor i in files:</span><br><span class=\"line\">\t\tliststr +&#x3D; i + &#39;\\n&#39;</span><br><span class=\"line\">\t#如果文件列表为空，将不继续执行下载任务</span><br><span class=\"line\">\tif operator.eq(liststr,&#39;&#39;): </span><br><span class=\"line\">\t\tconnect.send(&#39;&#39;.encode())</span><br><span class=\"line\">\t#如果文件列表不为空，开始下载任务</span><br><span class=\"line\">\telse :</span><br><span class=\"line\">\t\t#向客户端传送文件列表</span><br><span class=\"line\">\t\tconnect.send(liststr.encode())</span><br><span class=\"line\">\t\twhile  True:</span><br><span class=\"line\">\t\t\t#获取客户端要下载的文件名，如果不存在就继续输入</span><br><span class=\"line\">\t\t\tfilename &#x3D; connect.recv(100).decode()</span><br><span class=\"line\">\t\t\tif filename not in files:</span><br><span class=\"line\">\t\t\t\tconnect.send(&#39;文件不存在！&#39;.encode())</span><br><span class=\"line\">\t\t\telse:</span><br><span class=\"line\">\t\t\t\tconnect.send(&#39;开始文件传输！&#39;.encode())</span><br><span class=\"line\">\t\t\t\tbreak</span><br><span class=\"line\">\t\t#将文件信息打包发送给客服端</span><br><span class=\"line\">\t\tfhead &#x3D; struct.pack(&#39;128sI&#39;,filename.encode(),os.stat(filename).st_size)</span><br><span class=\"line\">\t\tconnect.send(fhead)</span><br><span class=\"line\">\t\t#传送文件信息</span><br><span class=\"line\">\t\twith open(filename,&#39;rb&#39;) as f:</span><br><span class=\"line\">\t\t\twhile True:</span><br><span class=\"line\">\t\t\t\tfiledata &#x3D; f.read(1024)</span><br><span class=\"line\">\t\t\t\tif not filedata:</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\tconnect.send(filedata)</span><br><span class=\"line\">\t\t#存储到日志中</span><br><span class=\"line\">\t\tprint (&#39;%s\\n下载文件:\\n%s\\n成功\\n\\n&#39;%(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())),filename))</span><br><span class=\"line\">\t\tos.chdir(&#39;..&#39;)</span><br><span class=\"line\">\t\twith open(&#39;data.log&#39;,&#39;a&#39;) as f:</span><br><span class=\"line\">\t\t\tf.write(&#39;%s\\n下载文件:\\n%s\\n成功\\n\\n&#39;%(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())),filename))</span><br><span class=\"line\">\t\tos.chdir(&#39;files&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">#实现上传功能</span><br><span class=\"line\">def upload(connect):</span><br><span class=\"line\">\tFILEINFO_SIZE &#x3D; struct.calcsize(&#39;128sI&#39;)</span><br><span class=\"line\">\ttry:</span><br><span class=\"line\">\t\t#获取打包好的文件信息，并解包</span><br><span class=\"line\">\t\tfhead &#x3D; connect.recv(FILEINFO_SIZE)</span><br><span class=\"line\">\t\tfilename , filesize &#x3D; struct.unpack(&#39;128sI&#39;,fhead)</span><br><span class=\"line\">\t\tfilename &#x3D; filename.decode().strip(&#39;\\00&#39;)</span><br><span class=\"line\">\t\t#文件名必须去掉\\00，否则会报错，此处为接收文件</span><br><span class=\"line\">\t\twith open (&#39;newnew_&#39;+ filename,&#39;wb&#39;) as f:</span><br><span class=\"line\">\t\t\tressize &#x3D; filesize</span><br><span class=\"line\">\t\t\twhile True:</span><br><span class=\"line\">\t\t\t\tif ressize&gt;1024:</span><br><span class=\"line\">\t\t\t\t\tfiledata &#x3D; connect.recv(1024)</span><br><span class=\"line\">\t\t\t\telse:</span><br><span class=\"line\">\t\t\t\t\tfiledata &#x3D; connect.recv(ressize)</span><br><span class=\"line\">\t\t\t\t\tf.write(filedata)</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\tif not filedata:</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\tf.write(filedata)</span><br><span class=\"line\">\t\t\t\tressize &#x3D; ressize - len(filedata)</span><br><span class=\"line\">\t\t\t\tif ressize &lt;0:</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t#存储到日志</span><br><span class=\"line\">\t\tprint (&#39;%s\\n传输文件:\\n%s\\n成功\\n\\n&#39;%(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())),filename))</span><br><span class=\"line\">\t\tos.chdir(&#39;..&#39;)</span><br><span class=\"line\">\t\twith open(&#39;data.log&#39;,&#39;a&#39;) as f:</span><br><span class=\"line\">\t\t\tf.write(&#39;%s\\n传输文件:\\n%s\\n成功\\n\\n&#39;%(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())),filename))</span><br><span class=\"line\">\t\tos.chdir(&#39;files&#39;)</span><br><span class=\"line\">\texcept Exception as e:</span><br><span class=\"line\">\t\tprint (&#39;%s\\n传输文件:\\n%s\\n成功\\n\\n&#39;%(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())),filename))</span><br><span class=\"line\">\t\tos.chdir(&#39;..&#39;)</span><br><span class=\"line\">\t\twith open(&#39;data.log&#39;,&#39;a&#39;) as f:</span><br><span class=\"line\">\t\t\tf.write(&#39;%s\\n传输文件:\\n%s\\n失败\\n\\n&#39;%(time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;,time.localtime(time.time())),filename))</span><br><span class=\"line\">\t\tos.chdir(&#39;files&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def handle(connect,address):</span><br><span class=\"line\">\tprint (&#39;%s:%s is connectting...&#39;%(address))</span><br><span class=\"line\">\twhile True:</span><br><span class=\"line\">\t\torder &#x3D; connect.recv(100).decode()</span><br><span class=\"line\">\t\tif operator.eq(order,&#39;1&#39;):</span><br><span class=\"line\">\t\t\tdownload(connect)</span><br><span class=\"line\">\t\telif operator.eq(order,&#39;2&#39;):</span><br><span class=\"line\">\t\t\tupload(connect)</span><br><span class=\"line\">\t\telif operator.eq(order,&#39;3&#39;):</span><br><span class=\"line\">\t\t\tconnect.close()</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\tconnect.send(&#39;&#39;&#39;</span><br><span class=\"line\">1、 下载文件</span><br><span class=\"line\">2、 上传文件</span><br><span class=\"line\">3、 退出</span><br><span class=\"line\">\t\t\t&#39;&#39;&#39;.encode())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">\tif not os.path.exists(&#39;files&#39;):</span><br><span class=\"line\">\t\tos.mkdir(&#39;files&#39;)</span><br><span class=\"line\">\t#工作目录换到files文件夹</span><br><span class=\"line\">\tos.chdir(&#39;files&#39;)</span><br><span class=\"line\">\t#建立socket链接，并监听8002端口</span><br><span class=\"line\">\tsock &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">\tsock.bind((&#39;&#39;,8002))</span><br><span class=\"line\">\tsock.listen(100)</span><br><span class=\"line\">\twhile True:</span><br><span class=\"line\">\t\tconnect,address &#x3D; sock.accept()</span><br><span class=\"line\">\t\tconnect.send(&#39;&#39;&#39;欢迎使用文件管理服务器，您已经成功连接，请选择您要选用的选项：</span><br><span class=\"line\">1、 下载文件</span><br><span class=\"line\">2、 上传文件</span><br><span class=\"line\">3、 退出</span><br><span class=\"line\">\t\t\t&#39;&#39;&#39;.encode())</span><br><span class=\"line\">\t\tt &#x3D; threading.Thread(target &#x3D; handle,args &#x3D; (connect,address))</span><br><span class=\"line\">\t\tt.setDaemon(True)</span><br><span class=\"line\">\t\tt.start()</span><br><span class=\"line\">\tsock.close()</span><br></pre></td></tr></table></figure>\n<p>以下是客户端的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-09-24 14:26:31</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Max</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">import socket</span><br><span class=\"line\">import struct</span><br><span class=\"line\">import operator</span><br><span class=\"line\">import time</span><br><span class=\"line\">import os</span><br><span class=\"line\">#实现下载功能</span><br><span class=\"line\">def download(sock):</span><br><span class=\"line\">\t#从服务端接收文件列表</span><br><span class=\"line\">\tfilelist &#x3D; sock.recv(1024).decode()</span><br><span class=\"line\">\tif operator.eq(filelist,&#39;&#39;):</span><br><span class=\"line\">\t\tprint (&#39;没有可以下载的文件&#39;)</span><br><span class=\"line\">\tprint (filelist)</span><br><span class=\"line\">\t#从用户中输入接收文件名，并发送给服务端</span><br><span class=\"line\">\tfilename  &#x3D; input(&#39;请输入要下载的文件名:\\n&#39;)</span><br><span class=\"line\">\tsock.send(filename.encode())</span><br><span class=\"line\">\t#获取包大小，并解压</span><br><span class=\"line\">\tFILEINFO_SIZE &#x3D; struct.calcsize(&#39;128sI&#39;)</span><br><span class=\"line\">\ttry:</span><br><span class=\"line\">\t\tfhead &#x3D; sock.recv(1024)</span><br><span class=\"line\">\t\tfhead &#x3D; sock.recv(FILEINFO_SIZE)</span><br><span class=\"line\">\t\tfilename , filesize &#x3D; struct.unpack(&#39;128sI&#39;,fhead)</span><br><span class=\"line\">\t\t#接收文件</span><br><span class=\"line\">\t\twith open (&#39;new_&#39;+filename.decode().strip(&#39;\\00&#39;),&#39;wb&#39;) as f:</span><br><span class=\"line\">\t\t\tressize &#x3D; filesize</span><br><span class=\"line\">\t\t\twhile True:</span><br><span class=\"line\">\t\t\t\tif ressize&gt;1024:</span><br><span class=\"line\">\t\t\t\t\tfiledata &#x3D; sock.recv(1024)</span><br><span class=\"line\">\t\t\t\telse:</span><br><span class=\"line\">\t\t\t\t\tfiledata &#x3D; sock.recv(ressize)</span><br><span class=\"line\">\t\t\t\t\tf.write(filedata)</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\tif not filedata:</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\t\t\tf.write(filedata)</span><br><span class=\"line\">\t\t\t\tressize &#x3D; ressize - len(filedata)</span><br><span class=\"line\">\t\t\t\tif ressize &lt;0:</span><br><span class=\"line\">\t\t\t\t\tbreak</span><br><span class=\"line\">\t\tprint (&#39;文件传输成功!&#39;)</span><br><span class=\"line\">\texcept Exception as e:</span><br><span class=\"line\">\t\tprint (e)</span><br><span class=\"line\">\t\tprint (&#39;文件传输失败!&#39;)</span><br><span class=\"line\">#实现上传功能</span><br><span class=\"line\">def upload(sock):</span><br><span class=\"line\">\t#获取文件路径，并将文件信息打包发送给服务端</span><br><span class=\"line\">\tpath &#x3D; input(&#39;请输入要上传的文件路径\\n&#39;)</span><br><span class=\"line\">\tfilename &#x3D; input(&#39;请输入文件名\\n&#39;)</span><br><span class=\"line\">\tfhead &#x3D; struct.pack(&#39;128sI&#39;,filename.encode(),os.stat(filename).st_size)</span><br><span class=\"line\">\tsock.send(fhead)</span><br><span class=\"line\">\t#传送文件</span><br><span class=\"line\">\twith open (path,&#39;rb&#39;) as f:</span><br><span class=\"line\">\t\twhile True:</span><br><span class=\"line\">\t\t\tfiledata &#x3D; f.read(1024)</span><br><span class=\"line\">\t\t\tif not filedata:</span><br><span class=\"line\">\t\t\t\tbreak</span><br><span class=\"line\">\t\t\tsock.send(filedata)</span><br><span class=\"line\">\tprint(&#39;文件传输结束&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">def  handle(sock):</span><br><span class=\"line\">\twhile True:</span><br><span class=\"line\">\t\torder &#x3D; input()</span><br><span class=\"line\">\t\tif operator.eq(order,&#39;1&#39;):</span><br><span class=\"line\">\t\t\tsock.send(order.encode())</span><br><span class=\"line\">\t\t\tdownload(sock)</span><br><span class=\"line\">\t\telif operator.eq(order,&#39;2&#39;):</span><br><span class=\"line\">\t\t\tsock.send(order.encode())</span><br><span class=\"line\">\t\t\tupload(sock)</span><br><span class=\"line\">\t\telif operator.eq(order,&#39;3&#39;):</span><br><span class=\"line\">\t\t\tprint(&#39;正在关闭连接...&#39;)</span><br><span class=\"line\">\t\t\ttime.sleep(0.5)</span><br><span class=\"line\">\t\t\tsock.send(order.encode())</span><br><span class=\"line\">\t\t\tbreak</span><br><span class=\"line\">\t\telse:</span><br><span class=\"line\">\t\t\tprint(&#39;命令错误,请重新输入！&#39;)</span><br><span class=\"line\">\t\t\tcontinue</span><br><span class=\"line\">\t\tline &#x3D; sock.recv(1024)</span><br><span class=\"line\">\t\tprint(line.decode())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">\t#建立socket并连接8002端口</span><br><span class=\"line\">\tsock &#x3D; socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class=\"line\">\tsock.connect((&#39;127.0.0.1&#39;,8002))</span><br><span class=\"line\">\tline &#x3D; sock.recv(1024)</span><br><span class=\"line\">\tprint(line.decode())</span><br><span class=\"line\">\thandle(sock)</span><br><span class=\"line\">\tsock.close()</span><br></pre></td></tr></table></figure>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/78076845第一次写Socket，大家见笑了。注释都很","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"Web安全之机器学习入门读书笔记——K近邻算法","slug":"Web安全之机器学习入门读书笔记——K近邻算法","date":"2018-01-25T08:51:56.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/Web安全之机器学习入门读书笔记——K近邻算法.json","excerpt":"","keywords":null,"cover":"../../../../image/1.png","content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/79154640\">https://blog.csdn.net/s1054436218/article/details/79154640</a></p>\n<p>网络空间安全和AI几乎是当下最热的两门话题了，而AI安全人才是少之又少，抱着这个想法和自己的兴趣，最近在读兜哥出的一本书：《Web安全之机器学习入门》。这几天会边读边写笔记，由于兜哥的代码都是用python2.7写的，个人比较喜欢python3.6，在写笔记的过程中可能与兜哥的源代码不符，顺便纠正一下书中的错误（试某个代码的时候一直跑错，到兜哥的GitHub上发现大家都说兜哥的代码的确写错了）。建议各位同好的朋友们去买兜哥的正版图书哈~我的笔记会省略兜哥讲到的很多姿势。以下是兜哥这本书的京东地址：<a href=\"https://item.jd.com/12158965.html\">https://item.jd.com/12158965.html</a></p>\n<p>本文所有代码以及数据都可以在我的GitHub上下载：<a href=\"https://github.com/UnnameBao/Note_For_MLFTWS/tree/master/Capter5\">Capter5</a></p>\n<p>K近邻算法算是最简单的机器学习算法了，也是比较重要的算法，简单易懂，书里介绍的相对简略，想更了解这个算法的朋友可以到这位大佬这里学习一下：<a href=\"http://blog.csdn.net/c406495762/article/details/75172850\">Python3《机器学习实战》学习笔记（一）：k-近邻算法(史诗级干货长文</a></p>\n<h2 id=\"使用k近邻算法检测异常操作一\"><a class=\"markdownIt-Anchor\" href=\"#使用k近邻算法检测异常操作一\"></a> 使用K近邻算法检测异常操作（一）</h2>\n<p>黑客入侵Web服务器以后，通常会通过系统漏洞进一步提权，获得root权限。所以我们可以利用搜集来的Linux服务器的bash操作日志，通过训练识别出特定用户的操作习惯，然后进一步识别出异常操作行为。<a href=\"http://xn--5-2-ns9dld28ohm95np5bw53f4rbmx8gtberr5h4dg.py\">兜哥这里写的代码文件名是5-2.py</a>，于是我这里写S的是test5_2.py。<br />\n首先是对训练数据的处理，训练数据中包括50个用户的操作日志，每个日志包含15000条操作命令，其中前5000条都是正常操作，后面的10000条日志中随机包含有异常操作。为了方便分析，数据集每100条操作作为一个操作系列，每个操作序列只要有1条异常数据就认为这个操作序列异常。<br />\n<img src=\"../../../../image/1.png\" alt=\"\" /></p>\n<h4 id=\"1-数据搜集和清洗\"><a class=\"markdownIt-Anchor\" href=\"#1-数据搜集和清洗\"></a> 1、数据搜集和清洗</h4>\n<p>一共50个User，其中label.txt记录每个User文件操作序列是否为异常，用于测试和训练，tmp.py是我自己写的脚本……<br />\n然后我们需要逐行读取操作命令，并且每100个命令组成一个操作序列，保存在list中：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def load_user_cmd(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist_max &#x3D; []\t\t#存储用户使用频率最高的50个命令</span><br><span class=\"line\">\tdist_min &#x3D; []\t\t#存储用户使用频率最低的50个命令</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tx.append(line)\t\t\t\t#组合成操作序列</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br></pre></td></tr></table></figure>\n<p>我们需要统计使用频率最高的50个命令和最低的50个命令，以判断用户的操作习惯，所以略微修改一下读入的函数：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def load_user_cmd(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist_max &#x3D; []\t\t#存储用户使用频率最高的50个命令</span><br><span class=\"line\">\tdist_min &#x3D; []\t\t#存储用户使用频率最低的50个命令</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tx.append(line)\t\t\t\t#组合成操作序列</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\tfdist    &#x3D; sorted(FreqDist(dist).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)\t#获得操作命令使用频率并排序</span><br><span class=\"line\">\tdist_max &#x3D; set([item[0] for item in fdist[:50]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\tdist_min &#x3D; set([item[0] for item in fdist[-50:]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\treturn cmd_list,dist_max,dist_min </span><br></pre></td></tr></table></figure>\n<p>使用FreqDist和operator.itemgetter之前记得首先要import一下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from nltk.probability import FreqDist</span><br><span class=\"line\">import operator</span><br></pre></td></tr></table></figure>\n<p>注意，这里我跟兜哥的代码不相同，兜哥原本获取操作指令频率的命令是：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdist &#x3D; FreqDist(dist).keys()</span><br><span class=\"line\">dist_max&#x3D;set(fdist[0:50])</span><br><span class=\"line\">dist_min &#x3D; set(fdist[-50:])</span><br><span class=\"line\">return cmd_list,dist_max,dist_min</span><br></pre></td></tr></table></figure>\n<p>然而这样获取的keys()是随机的，不是按照使用频率排序的，故后面都会出错（尽管我用兜哥的源代码仍然跑的概率和书上不同，改对后也不同）。set其实没有必要用，因为keys一定不会重复的，但是这样用也没有问题，向兜哥致敬吧，所以我没有把set去掉。<br />\n数据搜集和清洗的操作完成了，接下来将数据<strong>特征化</strong>。</p>\n<h4 id=\"2-特征化\"><a class=\"markdownIt-Anchor\" href=\"#2-特征化\"></a> 2、特征化</h4>\n<p>（1）获得每个操作序列去重后的指令个数：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1&#x3D;len(set(cmd_block))</span><br></pre></td></tr></table></figure>\n<p>（2）获得每个操作序列使用前10以及后10的命令（这里依旧和兜哥的源代码不同）：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fdist &#x3D; sorted(FreqDist(cmd_block).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)</span><br><span class=\"line\">f2 \t  &#x3D; [item[0] for item in fdist[:10]]</span><br><span class=\"line\">f3\t  &#x3D; [item[0] for item in fdist[-10:]]</span><br></pre></td></tr></table></figure>\n<p>KNN只能以标量作为输入参数，所以需要将f2和f3表量化，最简单的方式就是和统计的最频繁使用的前50个命令以及最不频繁的50个命令计算重合度：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">              f2        &#x3D; len(set(f2) &amp; set(dist_max))</span><br><span class=\"line\">f3        &#x3D; len(set(f3) &amp; set(dist_min))</span><br></pre></td></tr></table></figure>\n<p>最终，特征化函数为：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_user_cmd_feature(user_cmd_list,dist_max,dist_min):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tf1 \t  &#x3D; len(set(cmd_block))</span><br><span class=\"line\">\t\tfdist &#x3D; sorted(FreqDist(cmd_block).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)</span><br><span class=\"line\">\t\tf2 \t  &#x3D; [item[0] for item in fdist[:10]]</span><br><span class=\"line\">\t\tf3\t  &#x3D; [item[0] for item in fdist[-10:]]</span><br><span class=\"line\">\t\tf2\t  &#x3D; len(set(f2) &amp; set(dist_max))</span><br><span class=\"line\">\t\tf3        &#x3D; len(set(f3) &amp; set(dist_min))</span><br><span class=\"line\">\t\tx \t  &#x3D; [f1,f2,f3]</span><br><span class=\"line\">\t\tuser_cmd_feature.append(x)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-训练数据\"><a class=\"markdownIt-Anchor\" href=\"#3-训练数据\"></a> 3、训练数据</h4>\n<p>完成了数据读取和特征化后，我们即将开始训练数据，但在此之前，我们还需要把标志操作序列是否异常的标签读进来，提供监督学习：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_label(filename,index&#x3D;0):\t\t#读取标签，index+1即用户编号</span><br><span class=\"line\">\tx&#x3D;[]</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)</span><br><span class=\"line\">\t\t\tx.append(int(line.split()[index]))</span><br><span class=\"line\">\treturn x</span><br></pre></td></tr></table></figure>\n<p>加载user3的数据，然后进行测试和训练，前N个用作训练，其余的用作测试：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">\tuser_cmd_list,user_cmd_dist_max,user_cmd_dist_min &#x3D; load_user_cmd(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">\t#将数据特征化</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; get_user_cmd_feature(user_cmd_list,user_cmd_dist_max,user_cmd_dist_min)</span><br><span class=\"line\">\t#获得操作序列的标签</span><br><span class=\"line\">\tlabels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">\t#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">\ty &#x3D; [0]*50 + labels</span><br><span class=\"line\">\t#x代表特征化的数据，这里取了前N个数据</span><br><span class=\"line\">\tx_train &#x3D; user_cmd_feature[0:N]</span><br><span class=\"line\">\t#y代表数据的标签，这里取了前N个数据的标签</span><br><span class=\"line\">\ty_train  &#x3D; y[0:N]</span><br><span class=\"line\">\t#N个以后的都用作测试</span><br><span class=\"line\">\tx_test  &#x3D; user_cmd_feature[N:150]</span><br><span class=\"line\">\ty_test  &#x3D; y[N:150]</span><br></pre></td></tr></table></figure>\n<p>接下来要调用skearn的库来操作，首先需要import一下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from sklearn.neighbors import KNeighborsClassifier</span><br><span class=\"line\">import numpy as np</span><br></pre></td></tr></table></figure>\n<p>接下来调用KNN函数进行训练：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">       neigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">neigh.fit(x_train,y_train)</span><br></pre></td></tr></table></figure>\n<p>然后预测结果，并获得 准确率：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y_predict &#x3D; neigh.predict(x_test)</span><br><span class=\"line\">score &#x3D; np.mean(y_test &#x3D;&#x3D; y_predict)*100</span><br><span class=\"line\">print(score)</span><br></pre></td></tr></table></figure>\n<p>书上说是用前120个操作序列进行训练，后30进行测试，准确率是80%，然而无论我用书上的代码还是兜哥GitHub上的源代码跑出的准确率都是100%……包括我自己修正后的代码也是100，不过将训练的数据减小到50个，我修正后的代码跑出的准确率为89%:</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">89.0</span><br><span class=\"line\"></span><br><span class=\"line\">***Repl Closed***</span><br></pre></td></tr></table></figure>\n<p>OK，将所有代码整合在一起，如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2018-01-24 14:36:02</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">from nltk.probability import FreqDist</span><br><span class=\"line\">import operator</span><br><span class=\"line\">from sklearn.neighbors import KNeighborsClassifier</span><br><span class=\"line\">import numpy as np</span><br><span class=\"line\"></span><br><span class=\"line\">N &#x3D; 50</span><br><span class=\"line\">def load_user_cmd(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist_max &#x3D; []\t\t#存储用户使用频率最高的50个命令</span><br><span class=\"line\">\tdist_min &#x3D; []\t\t#存储用户使用频率最低的50个命令</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tx.append(line)\t\t\t\t#组合成操作序列</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\tfdist    &#x3D; sorted(FreqDist(dist).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)\t#获得操作命令使用频率并排序</span><br><span class=\"line\">\tdist_max &#x3D; set([item[0] for item in fdist[:50]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\tdist_min &#x3D; set([item[0] for item in fdist[-50:]])\t\t#取出前50个操作命令的指令</span><br><span class=\"line\">\treturn cmd_list,dist_max,dist_min </span><br><span class=\"line\"></span><br><span class=\"line\">def get_user_cmd_feature(user_cmd_list,dist_max,dist_min):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tf1 \t  &#x3D; len(set(cmd_block))</span><br><span class=\"line\">\t\tfdist &#x3D; sorted(FreqDist(cmd_block).items(),key &#x3D; operator.itemgetter(1),reverse &#x3D; True)</span><br><span class=\"line\">\t\tf2 \t  &#x3D; [item[0] for item in fdist[:10]]</span><br><span class=\"line\">\t\tf3\t  &#x3D; [item[0] for item in fdist[-10:]]</span><br><span class=\"line\">\t\tf2\t  &#x3D; len(set(f2) &amp; set(dist_max))</span><br><span class=\"line\">\t\tf3    &#x3D; len(set(f3) &amp; set(dist_min))</span><br><span class=\"line\">\t\tx \t  &#x3D; [f1,f2,f3]</span><br><span class=\"line\">\t\tuser_cmd_feature.append(x)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br><span class=\"line\"></span><br><span class=\"line\">def get_label(filename,index&#x3D;0):\t\t#读取标签，index+1即用户编号</span><br><span class=\"line\">\tx&#x3D;[]</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)</span><br><span class=\"line\">\t\t\tx.append(int(line.split()[index]))</span><br><span class=\"line\">\treturn x</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">\t#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">\tuser_cmd_list,user_cmd_dist_max,user_cmd_dist_min &#x3D; load_user_cmd(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">\t#将数据特征化</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; get_user_cmd_feature(user_cmd_list,user_cmd_dist_max,user_cmd_dist_min)</span><br><span class=\"line\">\t#获得操作序列的标签</span><br><span class=\"line\">\tlabels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">\t#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">\ty &#x3D; [0]*50 + labels</span><br><span class=\"line\">\t#x代表特征化的数据，这里取了前N个数据</span><br><span class=\"line\">\tx_train &#x3D; user_cmd_feature[0:N]</span><br><span class=\"line\">\t#y代表数据的标签，这里取了前N个数据的标签</span><br><span class=\"line\">\ty_train  &#x3D; y[0:N]</span><br><span class=\"line\">\t#N个以后的都用作测试</span><br><span class=\"line\">\tx_test  &#x3D; user_cmd_feature[N:150]</span><br><span class=\"line\">\ty_test  &#x3D; y[N:150]</span><br><span class=\"line\">\tneigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">\tneigh.fit(x_train,y_train)</span><br><span class=\"line\">\ty_predict &#x3D; neigh.predict(x_test)</span><br><span class=\"line\">\tscore &#x3D; np.mean(y_test &#x3D;&#x3D; y_predict)*100</span><br><span class=\"line\">\tprint(score)</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用k近邻算法检测异常操作二\"><a class=\"markdownIt-Anchor\" href=\"#使用k近邻算法检测异常操作二\"></a> 使用K近邻算法检测异常操作（二）</h2>\n<p>之前的方法只比较了最频繁和最不频繁的操作命令，这次我们尝试一下全量比较。</p>\n<h4 id=\"1-数据搜集和数据清洗\"><a class=\"markdownIt-Anchor\" href=\"#1-数据搜集和数据清洗\"></a> 1、数据搜集和数据清洗</h4>\n<p>由于这次是全量化处理，所以不需要再统计频率了，函数修改成以下：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def load_user_cmd_new(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\treturn cmd_list,list(set(dist))</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-特征化-2\"><a class=\"markdownIt-Anchor\" href=\"#2-特征化-2\"></a> 2、特征化</h4>\n<p>特征化也很简单，对于出现过的命令置为1即可：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def get_user_cmd_feature_new(user_cmd_list,dist):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tv &#x3D; [0]*len(dist)\t\t\t\t#v为向量，初始全为0</span><br><span class=\"line\">\t\tfor i in range(len(dist)):</span><br><span class=\"line\">\t\t\tif dist[i] in cmd_block:</span><br><span class=\"line\">\t\t\t\tv[i] &#x3D; 1\t\t\t\t#一旦使用过某序号的命令，置为1</span><br><span class=\"line\">\t\tuser_cmd_feature.append(v)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-训练数据及验证\"><a class=\"markdownIt-Anchor\" href=\"#3-训练数据及验证\"></a> 3、训练数据及验证</h4>\n<p>和之前类似，这次使用交叉验证，10次随机取样和验证，提高验证可信度。</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">user_cmd_list,dist &#x3D; load_user_cmd_new(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">#将数据特征化</span><br><span class=\"line\">user_cmd_feature &#x3D; get_user_cmd_feature_new(user_cmd_list,dist)</span><br><span class=\"line\">#获得操作序列的标签</span><br><span class=\"line\">labels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">y &#x3D; [0]*50 + labels</span><br><span class=\"line\">neigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">#交叉验证，10次随机取样，n_jobs&#x3D;-1表示使用全部CPU运行</span><br><span class=\"line\">print(model_selection.cross_val_score(neigh,user_cmd_feature,y,n_jobs&#x3D;-1,cv&#x3D;10))</span><br></pre></td></tr></table></figure>\n<p>最终代码为：</p>\n <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2018-01-25 16:22:47</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">from nltk.probability import FreqDist</span><br><span class=\"line\">import operator</span><br><span class=\"line\">from sklearn.neighbors import KNeighborsClassifier</span><br><span class=\"line\">from sklearn import model_selection</span><br><span class=\"line\">import numpy as np</span><br><span class=\"line\"></span><br><span class=\"line\">def load_user_cmd_new(filename):</span><br><span class=\"line\">\tcmd_list &#x3D; []\t\t#存储所有操作序列</span><br><span class=\"line\">\tdist     &#x3D; []\t\t#存储所有命令</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\ti &#x3D; 0</span><br><span class=\"line\">\t\tx &#x3D; []\t\t\t#存储每个操作序列</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)\t\t#去掉空行</span><br><span class=\"line\">\t\t\tdist.append(line)\t\t\t#添加操作命令</span><br><span class=\"line\">\t\t\ti+&#x3D;1</span><br><span class=\"line\">\t\t\tif i&#x3D;&#x3D;100:</span><br><span class=\"line\">\t\t\t\tcmd_list.append(x)\t\t#每计数100个添加操作序列</span><br><span class=\"line\">\t\t\t\tx &#x3D; []\t\t\t\t\t#然后将操作序列清空</span><br><span class=\"line\">\t\t\t\ti &#x3D; 0</span><br><span class=\"line\">\treturn cmd_list,list(set(dist))</span><br><span class=\"line\"></span><br><span class=\"line\">def get_user_cmd_feature_new(user_cmd_list,dist):</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; []</span><br><span class=\"line\">\tfor cmd_block in user_cmd_list:</span><br><span class=\"line\">\t\tv &#x3D; [0]*len(dist)\t\t\t\t#v为向量，初始全为0</span><br><span class=\"line\">\t\tfor i in range(len(dist)):</span><br><span class=\"line\">\t\t\tif dist[i] in cmd_block:</span><br><span class=\"line\">\t\t\t\tv[i] &#x3D; 1\t\t\t\t#一旦使用过某序号的命令，置为1</span><br><span class=\"line\">\t\tuser_cmd_feature.append(v)</span><br><span class=\"line\">\treturn user_cmd_feature</span><br><span class=\"line\"></span><br><span class=\"line\">def get_label(filename,index&#x3D;0):\t\t#读取标签，index+1即用户编号</span><br><span class=\"line\">\tx&#x3D;[]</span><br><span class=\"line\">\twith open(filename) as f:</span><br><span class=\"line\">\t\tfor line in f:</span><br><span class=\"line\">\t\t\tline &#x3D; line.strip(&#39;\\n&#39;)</span><br><span class=\"line\">\t\t\tx.append(int(line.split()[index]))</span><br><span class=\"line\">\treturn x</span><br><span class=\"line\"></span><br><span class=\"line\">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class=\"line\">\t#读取用户操作序列，并做数据清洗</span><br><span class=\"line\">\tuser_cmd_list,dist &#x3D; load_user_cmd_new(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;User3&#39;)</span><br><span class=\"line\">\t#将数据特征化</span><br><span class=\"line\">\tuser_cmd_feature &#x3D; get_user_cmd_feature_new(user_cmd_list,dist)</span><br><span class=\"line\">\t#获得操作序列的标签</span><br><span class=\"line\">\tlabels &#x3D; get_label(&#39;..&#x2F;Capter5&#x2F;MasqueradeDat&#x2F;label.txt&#39;,2)</span><br><span class=\"line\">\t#label.txt中只有后100个序列的标签，前50个都是正常用户的操作序列</span><br><span class=\"line\">\ty &#x3D; [0]*50 + labels</span><br><span class=\"line\">\tneigh   &#x3D; KNeighborsClassifier(n_neighbors &#x3D; 3)</span><br><span class=\"line\">\t#交叉验证，10次随机取样，n_jobs&#x3D;-1表示使用全部CPU运行</span><br><span class=\"line\">\tprint(model_selection.cross_val_score(neigh,user_cmd_feature,y,n_jobs&#x3D;-1,cv&#x3D;10))</span><br></pre></td></tr></table></figure>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/79154640网络空间安全和AI几乎是当下最热的两门话题","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"使用z3约束器解决CTF中的题目","slug":"使用z3约束器解决CTF中的题目","date":"2017-11-28T02:53:22.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/使用z3约束器解决CTF中的题目.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78651075\">https://blog.csdn.net/s1054436218/article/details/78651075</a></p>\n<p>Z3是什么？Z3由微软开发的一套约束求解器，你可以简单的理解它是解方程的神器。在CTF题目中，我们经常遇到一些给定的条件，或是算法难以逆向、或是涉及到未知的数学技巧又或是爆破时间过长，而在我们学会使用z3后，一类问题便迎刃而解了。想了解更多关于z3知识的，这里有篇专栏：<a href=\"https://zhuanlan.zhihu.com/p/30548907\">点我</a></p>\n<p>一个简单的例子给大家介绍一下z3如何使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from z3 import *</span><br><span class=\"line\">&gt;&gt;&gt; x &#x3D; Int(&#39;x&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; y &#x3D; Int(&#39;y&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; solve(x+y&#x3D;&#x3D;4)</span><br><span class=\"line\">[y &#x3D; 0, x &#x3D; 4]</span><br></pre></td></tr></table></figure>\n<p>它为我们提供了一个关于x+y==4的解，可是如果我们想要x=3呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; solve(x&#x3D;&#x3D;3,x+y&#x3D;&#x3D;4)</span><br><span class=\"line\">[y &#x3D; 1, x &#x3D; 3]</span><br></pre></td></tr></table></figure>\n<p>当然了，z3能做的肯定不止这么简单的运算，例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; from z3 import *</span><br><span class=\"line\">&gt;&gt;&gt; x &#x3D; Real(&#39;x&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; y &#x3D; Real(&#39;y&#39;)</span><br><span class=\"line\">&gt;&gt;&gt; solve(x**2 + y**2 &#x3D;&#x3D; 3, x**3 &#x3D;&#x3D; 2)</span><br><span class=\"line\">[x &#x3D; 1.2599210498?, y &#x3D; -1.1885280594?]</span><br></pre></td></tr></table></figure>\n<p>OK，大概了解到它是干嘛的我们就开始看一道例题吧。二进制文件可以在<a href=\"https://github.com/UnnameBao/My_ctf_path/tree/master/blog/I_Hate_Math\">这里</a>下载。</p>\n<p>这是whctf的一道逆向题，它的核心代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v1 &#x3D; 0;</span><br><span class=\"line\">gets(flag);</span><br><span class=\"line\">for ( i &#x3D; 0; i &lt;&#x3D; 35; ++i )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  if ( !flag[i] )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    flag[i] &#x3D; 1;</span><br><span class=\"line\">    ++v1;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if ( v1 !&#x3D; 9 )</span><br><span class=\"line\">  exit(0);</span><br><span class=\"line\">convert(a);</span><br><span class=\"line\">Transposition(a);</span><br><span class=\"line\">Multi(a, b);</span><br><span class=\"line\">for ( j &#x3D; 0; j &lt;&#x3D; 5; ++j )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  for ( k &#x3D; 0; k &lt;&#x3D; 5; ++k )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    if ( c[0][k + 6 * j] !&#x3D; d[0][k + 6 * j] )</span><br><span class=\"line\">      exit(0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">printf(&quot;congratulations!you have gottern the flag!&quot;);</span><br></pre></td></tr></table></figure>\n<p>其中convert(a)是将flag赋值给a，你可以把a当做一个6*6的矩阵。 Transposition(a)是把a的转置矩阵赋值给b</p>\n<p>Multi(a,b)是把a和b的乘积赋值给c</p>\n<p>而d就是堆中正确的flag经过上述运算后的结果，也就是说，如果用简单的思路去做，就是想办法爆破27位的flag添加9位1到尾部，然后经过运算结果为d中的值。但未知位数已经达到了20个，常规的爆破思路很难解决，网上的一篇writeup是经过一系列数学运算后逐行爆破，但每行依旧要消耗近10分钟的时间。在实际比赛的过程中，时间始终是最宝贵的，况且如果你对线性代数不太理解，可能会有一些棘手。</p>\n<p>首先数学知识当然是必要的，我们应该保持着一个敬畏之心去学习这里的数学原理，但为了节省时间，或许用约束器去做会有意想不到的效果。</p>\n<p>以下是我的脚本，注释的很详细就不多说了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-28 10:19:29</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">from z3 import *</span><br><span class=\"line\">import time</span><br><span class=\"line\">t1 &#x3D; time.time()</span><br><span class=\"line\">#创建一个解决方案实例</span><br><span class=\"line\">solver &#x3D; Solver()</span><br><span class=\"line\">#flag长度先设置为36，包括尾部的9个1</span><br><span class=\"line\">flag &#x3D; [Int(&#39;flag%d&#39;%i) for i in range(36)]</span><br><span class=\"line\">#保存flag的矩阵</span><br><span class=\"line\">a &#x3D; [i for i in flag]</span><br><span class=\"line\">#保存flag的转置矩阵</span><br><span class=\"line\">b &#x3D; [i for i in range(36)]</span><br><span class=\"line\">#保存a*b的矩阵</span><br><span class=\"line\">c &#x3D; [0 for i in range(36)]</span><br><span class=\"line\">#堆中正确flag的运算结果</span><br><span class=\"line\">d &#x3D; [0x12027,0x0F296,0x0BF0E,0x0D84C,0x91D8,0x297,</span><br><span class=\"line\">\t0x0F296,0x0D830,0x0A326,0x0B010,0x7627,0x230,</span><br><span class=\"line\">\t0x0BF0E,0x0A326,0x8FEB,0x879D,0x70C3,0x1BD,</span><br><span class=\"line\">\t0x0D84C,0x0B010,0x879D,0x0B00D,0x6E4F,0x1F7,</span><br><span class=\"line\">\t0x91D8,0x7627,0x70C3,0x6E4F,0x9BDC,0x15C,</span><br><span class=\"line\">\t0x297,0x230,0x1BD,0x1F7,0x15C,0x6]</span><br><span class=\"line\">#获得a的转置矩阵</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tfor j in range(6):</span><br><span class=\"line\">\t\tb[i+6*j] &#x3D; a[6*i+j]</span><br><span class=\"line\">#运算a*b</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tfor j in range(6):</span><br><span class=\"line\">\t\tfor k in range(6):</span><br><span class=\"line\">\t\t\tc[j+6*i] &#x3D; c[j+6*i] + a[6*i+k]*b[6*k+j]</span><br><span class=\"line\">\t\t#添加约束，正确flag的运算结果</span><br><span class=\"line\">\t\tsolver.add(simplify(c[j+6*i]) &#x3D;&#x3D; d[j+6*i])</span><br><span class=\"line\">#添加约束，除了尾部，flag的字符一定在可见字符范围内</span><br><span class=\"line\">for i in range(6,36-10):</span><br><span class=\"line\">\tsolver.add(flag[i]&gt;&#x3D;32)</span><br><span class=\"line\">\tsolver.add(flag[i]&lt;&#x3D;127)</span><br><span class=\"line\">#添加约束，由于flag有格式，前6位一定为whctf&#123;</span><br><span class=\"line\">for i in range(6):</span><br><span class=\"line\">\tsolver.add(flag[i] &#x3D;&#x3D; ord(&#39;whctf&#123;&#39;[i]))</span><br><span class=\"line\">#添加约束，flag的尾部为9个1</span><br><span class=\"line\">for i in range(36-9,36):</span><br><span class=\"line\">\tsolver.add(flag[i] &#x3D;&#x3D; 0x1)</span><br><span class=\"line\">#添加约束，flag的最后一个肯定是&#125;</span><br><span class=\"line\">solver.add(flag[-10] &#x3D;&#x3D; ord(&#39;&#125;&#39;))</span><br><span class=\"line\">#这里一定要有，不check的话会报错</span><br><span class=\"line\">if solver.check() &#x3D;&#x3D; sat:</span><br><span class=\"line\">\tm &#x3D; solver.model()</span><br><span class=\"line\">\ts &#x3D; []</span><br><span class=\"line\">\t#获得结果</span><br><span class=\"line\">\tfor i in range(36):</span><br><span class=\"line\">\t\ts.append(m[flag[i]].as_long())</span><br><span class=\"line\">\t#输出flag</span><br><span class=\"line\">\tprint(bytes(s))</span><br><span class=\"line\">else:</span><br><span class=\"line\">\tprint(&#39;error&#39;)</span><br><span class=\"line\">t2 &#x3D; time.time()</span><br><span class=\"line\">print(t2-t1)</span><br></pre></td></tr></table></figure>\n<p>这是最终的运行结果：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">D:\\2017_WEB_Test\\ulb_manager\\backend\\spider&gt;python z3test.py</span><br><span class=\"line\">b&#39;whctf&#123;Y0u_ar3_g00d_a7_m4th&#125;\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01\\x01&#39;</span><br><span class=\"line\">4.042840003967285</span><br></pre></td></tr></table></figure>\n<p>是的，仅仅用了4s就跑出了最终结果、可见z3约束器的强大！</p>\n<p>更多信息请看z3的官方GitHub：<a href=\"https://github.com/Z3Prover/z3\">点我</a></p>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/78651075Z3是什么？Z3由微软开发的一套约束求解器","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"关于python3中整数数组转bytes的效率问题","slug":"关于python3中整数数组转bytes的效率问题","date":"2017-11-26T06:10:06.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/关于python3中整数数组转bytes的效率问题.json","excerpt":"","keywords":null,"cover":null,"content":"<p><a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> </a> 版权声明：本文为博主原创文章，遵循<a href=\"http://creativecommons.org/licenses/by-sa/4.0/\"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。  本文链接：<a href=\"https://blog.csdn.net/s1054436218/article/details/78637048\">https://blog.csdn.net/s1054436218/article/details/78637048</a></p>\n<p>昨天在做一道CTF题的时候碰到了一个图片异或的问题，操作大概如下：</p>\n<p>将一个图片读入，然后每字节进行异或操作，核心代码可简化为以下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-25 13:51:33</span><br><span class=\"line\">\t@Version: \t1.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">import six</span><br><span class=\"line\">key &#x3D; b&#39;\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d&#39;</span><br><span class=\"line\">with open(&#39;flag.encrypted&#39;,&#39;rb&#39;) as f:</span><br><span class=\"line\">\tc &#x3D; f.read()</span><br><span class=\"line\">flag &#x3D; b&#39;&#39;</span><br><span class=\"line\">for i in range(32):</span><br><span class=\"line\">\tflag +&#x3D; six.int2byte(key[i%32]^c[i])</span><br><span class=\"line\">with open(&#39;flag.png&#39;,&#39;wb&#39;) as f:</span><br><span class=\"line\">\tf.write(flag)</span><br></pre></td></tr></table></figure>\n<p>然后就碰到了一个效率问题，跑了十几分钟都没有跑出结果，起初以为是类型转换的问题，因为比较急，于是换了成了C++的代码去解决，后来一直没多想。今天闲下来的时候才发现代码之前的代码中存在一个非常大的问题：内存申请问题。</p>\n<p>由于flag.encrypted文件大小为6.47MB之大，由于我的脚本思路是不断在byte数组后添加，但忽略了其本质。就是在内存申请过程中，由于数组长度最终为600+W大小，期间存在多次数组内存不够，需要重新申请内存的问题，而python中的内存申请显然没有C++的vector的push_back有效率。而且python中，无论是list、string还是byte，也没有reserve这种函数，不能预留内存空间（这时候真的要吐槽一下python设计者对速度优化的考量了）。于是只能用另一种方法进行优化，就是先用list申请一个需求大小的内存空间，然后再转为bytes使用，代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#coding:utf-8</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">\t@DateTime: \t2017-11-26 14:09:29</span><br><span class=\"line\">\t@Version: \t2.0</span><br><span class=\"line\">\t@Author: \tUnname_Bao</span><br><span class=\"line\">&#39;&#39;&#39;</span><br><span class=\"line\">key &#x3D; b&#39;\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d\\xdcd~\\xb6^g\\x11\\xe1U7R\\x18!+9d&#39;</span><br><span class=\"line\">with open(&#39;flag.encrypted&#39;,&#39;rb&#39;) as f:</span><br><span class=\"line\">\tc &#x3D; f.read()</span><br><span class=\"line\">flag &#x3D; list(&#39;1&#39;*len(c))</span><br><span class=\"line\">for i in  range(len(c)):</span><br><span class=\"line\">\tflag[i] &#x3D; key[i%32]^c[i]</span><br><span class=\"line\">flag &#x3D; bytes(flag)</span><br><span class=\"line\">with open(&#39;flag.png&#39;,&#39;wb&#39;) as f:</span><br><span class=\"line\">\tf.write(flag)</span><br></pre></td></tr></table></figure>\n<p>这样写的话几乎是瞬间完成任务了，但还是比C++慢很多，这是不可避免的。</p>\n","text":"  版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。  本文链接：https://blog.csdn.net/s1054436218/article/details/78637048昨天在做一道CTF题的时候碰到了一个图片异","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]},{"title":"解决GitHub下载速度太慢的问题","slug":"解决GitHub下载速度太慢的问题","date":"2019-01-05T04:20:44.000Z","updated":"2021-02-22T15:52:29.772Z","comments":true,"path":"api/articles/解决GitHub下载速度太慢的问题.json","excerpt":"","keywords":null,"cover":null,"content":"<p>方法一：</p>\n<p>从GitHub下载文件一直非常慢，查看下载链接发现最终被指向了Amazon的服务器，下载地址是http://github-cloud.s3.amazonaws.com/，从国内访问Amazon非常慢，所以总是下载失败，解决方法时更改host文件，使该域名指向香港的服务器：</p>\n<p>更改hosts文件：</p>\n<ul>\n<li>Windows</li>\n</ul>\n<blockquote>\n<p>更改 <code>C:\\Windows\\System32\\drivers\\etc\\hosts</code> 文件，在文件中追加 <code>219.76.4.4 github-cloud.s3.amazonaws.com</code> , 将域名指向该IP即可</p>\n</blockquote>\n<ul>\n<li>Mac</li>\n</ul>\n<blockquote>\n<p>执行  <code>sudo vi /etc/hosts</code>  追加  <code>219.76.4.4 github-cloud.s3.amazonaws.com</code></p>\n</blockquote>\n<p><strong>最后执行</strong> <code>ipconfig /flushdns</code> <strong>命令，刷新 DNS 缓存。</strong></p>\n<p><strong>方法二：</strong></p>\n<p><a href=\"https://www.ipaddress.com/\">https://www.ipaddress.com/</a> 使用 IP Lookup 工具获得下面这两个github域名的ip地址，该网站可能需要梯子，输入上述域名后，分别获得github.com和github.global.ssl.fastly.net对应的ip，比如192.30.xx.xx和151.101.xx.xx。准备工作做完之后，打开的hosts文件中添加如下格式，IP修改为自己查询到的IP：</p>\n<p>192.30.xx.xx <a href=\"http://github.com\">github.com</a><br />\n151.101.xx.xx <a href=\"http://github.global.ssl.fastly.net\">github.global.ssl.fastly.net</a></p>\n<p>最后执行 <code>ipconfig /flushdns</code> 命令，刷新 DNS 缓存。修改后的下载速度能达到 200KB/S 以上。</p>\n","text":"方法一：从GitHub下载文件一直非常慢，查看下载链接发现最终被指向了Amazon的服务器，下载地址是http://github-cloud.s3.amazonaws.com/，从国内访问Amazon非常慢，所以总是下载失败，解决方法时更改host文件，使该域名指向香港的服务器：","link":"","raw":null,"photos":[],"categories":[],"tags":[{"name":"CSDN迁移","slug":"CSDN迁移","count":6,"path":"api/tags/CSDN迁移.json"}]}]}